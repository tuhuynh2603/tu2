///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 13.0.2.2
///////////////////////////////////////////////////////////////////////////////




#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#endif



using namespace HalconCpp;


// Chapter: File / Misc
// Short Description: Get all image files under the given path 
void list_image_files (HTuple hv_ImageDirectory, HTuple hv_Extensions, HTuple hv_Options, 
    HTuple *hv_ImageFiles)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_HalconImages, hv_OS, hv_Directories;
  HTuple  hv_Index, hv_Length, hv_NetworkDrive, hv_Substring;
  HTuple  hv_FileExists, hv_AllFiles, hv_i, hv_Selection;

  //This procedure returns all files in a given directory
  //with one of the suffixes specified in Extensions.
  //
  //Input parameters:
  //ImageDirectory: as the name says
  //   If a tuple of directories is given, only the images in the first
  //   existing directory are returned.
  //   If a local directory is not found, the directory is searched
  //   under %HALCONIMAGES%/ImageDirectory. If %HALCONIMAGES% is not set,
  //   %HALCONROOT%/images is used instead.
  //Extensions: A string tuple containing the extensions to be found
  //   e.g. ['png','tif',jpg'] or others
  //If Extensions is set to 'default' or the empty string '',
  //   all image suffixes supported by HALCON are used.
  //Options: as in the operator list_files, except that the 'files'
  //   option is always used. Note that the 'directories' option
  //   has no effect but increases runtime, because only files are
  //   returned.
  //
  //Output parameter:
  //ImageFiles: A tuple of all found image file names
  //
  if (0 != (HTuple(HTuple(hv_Extensions==HTuple()).TupleOr(hv_Extensions==HTuple(""))).TupleOr(hv_Extensions==HTuple("default"))))
  {
    hv_Extensions.Clear();
    hv_Extensions[0] = "ima";
    hv_Extensions[1] = "tif";
    hv_Extensions[2] = "tiff";
    hv_Extensions[3] = "gif";
    hv_Extensions[4] = "bmp";
    hv_Extensions[5] = "jpg";
    hv_Extensions[6] = "jpeg";
    hv_Extensions[7] = "jp2";
    hv_Extensions[8] = "jxr";
    hv_Extensions[9] = "png";
    hv_Extensions[10] = "pcx";
    hv_Extensions[11] = "ras";
    hv_Extensions[12] = "xwd";
    hv_Extensions[13] = "pbm";
    hv_Extensions[14] = "pnm";
    hv_Extensions[15] = "pgm";
    hv_Extensions[16] = "ppm";
    //
  }
  if (0 != (hv_ImageDirectory==HTuple("")))
  {
    hv_ImageDirectory = ".";
  }
  GetSystem("image_dir", &hv_HalconImages);
  GetSystem("operating_system", &hv_OS);
  if (0 != ((hv_OS.TupleSubstr(0,2))==HTuple("Win")))
  {
    hv_HalconImages = hv_HalconImages.TupleSplit(";");
  }
  else
  {
    hv_HalconImages = hv_HalconImages.TupleSplit(":");
  }
  hv_Directories = hv_ImageDirectory;
  {
  HTuple end_val37 = (hv_HalconImages.TupleLength())-1;
  HTuple step_val37 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val37, step_val37); hv_Index += step_val37)
  {
    hv_Directories = hv_Directories.TupleConcat((HTuple(hv_HalconImages[hv_Index])+"/")+hv_ImageDirectory);
  }
  }
  TupleStrlen(hv_Directories, &hv_Length);
  TupleGenConst(hv_Length.TupleLength(), 0, &hv_NetworkDrive);
  if (0 != ((hv_OS.TupleSubstr(0,2))==HTuple("Win")))
  {
    {
    HTuple end_val43 = (hv_Length.TupleLength())-1;
    HTuple step_val43 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val43, step_val43); hv_Index += step_val43)
    {
      if (0 != ((HTuple(hv_Directories[hv_Index]).TupleStrlen())>1))
      {
        TupleStrFirstN(HTuple(hv_Directories[hv_Index]), 1, &hv_Substring);
        if (0 != (HTuple(hv_Substring==HTuple("//")).TupleOr(hv_Substring==HTuple("\\\\"))))
        {
          hv_NetworkDrive[hv_Index] = 1;
        }
      }
    }
    }
  }
  (*hv_ImageFiles) = HTuple();
  {
  HTuple end_val53 = (hv_Directories.TupleLength())-1;
  HTuple step_val53 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val53, step_val53); hv_Index += step_val53)
  {
    FileExists(HTuple(hv_Directories[hv_Index]), &hv_FileExists);
    if (0 != hv_FileExists)
    {
      ListFiles(HTuple(hv_Directories[hv_Index]), HTuple("files").TupleConcat(hv_Options), 
          &hv_AllFiles);
      (*hv_ImageFiles) = HTuple();
      {
      HTuple end_val58 = (hv_Extensions.TupleLength())-1;
      HTuple step_val58 = 1;
      for (hv_i=0; hv_i.Continue(end_val58, step_val58); hv_i += step_val58)
      {
        TupleRegexpSelect(hv_AllFiles, ((".*"+HTuple(hv_Extensions[hv_i]))+"$").TupleConcat("ignore_case"), 
            &hv_Selection);
        (*hv_ImageFiles) = (*hv_ImageFiles).TupleConcat(hv_Selection);
      }
      }
      TupleRegexpReplace((*hv_ImageFiles), (HTuple("\\\\").Append("replace_all")), 
          "/", &(*hv_ImageFiles));
      if (0 != (HTuple(hv_NetworkDrive[hv_Index])))
      {
        TupleRegexpReplace((*hv_ImageFiles), (HTuple("//").Append("replace_all")), 
            "/", &(*hv_ImageFiles));
        (*hv_ImageFiles) = "/"+(*hv_ImageFiles);
      }
      else
      {
        TupleRegexpReplace((*hv_ImageFiles), (HTuple("//").Append("replace_all")), 
            "/", &(*hv_ImageFiles));
      }
      return;
    }
  }
  }
  return;
}
