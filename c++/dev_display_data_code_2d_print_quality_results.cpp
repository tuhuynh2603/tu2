///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 13.0.2.2
///////////////////////////////////////////////////////////////////////////////




#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#endif



using namespace HalconCpp;


// Chapter: Identification / Data Code
// Short Description: Display print quality information for individual data code modules. 
void dev_display_data_code_2d_print_quality_results (HTuple hv_DataCodeHandle, HTuple hv_ResultHandle, 
    HTuple hv_Mode, HTuple hv_QualityStandard, HTuple hv_Color, HTuple hv_GenParamName, 
    HTuple hv_GenParamValue)
{

  // Local iconic variables
  HObject  ho_Circle, ho_Cross;

  // Local control variables
  HTuple  hv_MODE_RMMG, hv_MODE_GRID, hv_MODE_BAD;
  HTuple  hv_SupportedModes, hv_SupportedQualityStandards;
  HTuple  hv_GEN_CENTER, hv_GEN_CIRCLE, hv_GEN_LEGEND, hv_GEN_MAX_GRADE;
  HTuple  hv_DisplayCenter, hv_DisplayCircle, hv_DisplayLegend;
  HTuple  hv_MaxGrade, hv_I, hv_QualityParameter, hv_QualityRows;
  HTuple  hv_QualityCols, hv_ModuleGrades, hv_Rows, hv_Cols;
  HTuple  hv_QualityLabels, hv_Grades, hv_Labels, hv_ModuleHeight;
  HTuple  hv_ModuleWidth, hv_Aperture, hv_Radius, hv_Grade;
  HTuple  hv_GradeIdx, hv_GradeRows, hv_GradeCols, hv_GradeRadius;

  //This procedure displays the print quality results for data matrix ECC 200 codes.
  //
  //
  //Available modes
  hv_MODE_RMMG = "reflectance_margin_module_grades";
  hv_MODE_GRID = "grid";
  hv_MODE_BAD = "bad_modules";
  hv_SupportedModes.Clear();
  hv_SupportedModes.Append(hv_MODE_RMMG);
  hv_SupportedModes.Append(hv_MODE_GRID);
  hv_SupportedModes.Append(hv_MODE_BAD);
  //Available standards
  hv_SupportedQualityStandards.Clear();
  hv_SupportedQualityStandards[0] = "isoiec15415";
  hv_SupportedQualityStandards[1] = "isoiec_tr_29158";
  hv_SupportedQualityStandards[2] = "aimdpm_1_2006";
  //Available generic parameters
  hv_GEN_CENTER = "center";
  hv_GEN_CIRCLE = "circle";
  hv_GEN_LEGEND = "legend";
  hv_GEN_MAX_GRADE = "max_grade";
  //Defaults
  hv_DisplayCenter = 0;
  hv_DisplayCircle = 1;
  hv_DisplayLegend = 1;
  hv_MaxGrade = 3;
  //
  //Check modes
  if (0 != ((hv_Mode.TupleLength())!=1))
  {
    throw HException("Please specify exactly one of following modes:"+((" "+hv_SupportedModes).TupleSum()));
  }
  if (0 != ((hv_SupportedModes.TupleFind(hv_Mode))==-1))
  {
    throw HException("Unknown Mode: "+hv_Mode);
  }
  //
  //Check QualityStandard
  if (0 != ((hv_SupportedQualityStandards.TupleFind(hv_QualityStandard))==-1))
  {
    throw HException("Unknown QualityStandard: "+hv_QualityStandard);
  }
  else
  {
    hv_QualityStandard = "quality_"+hv_QualityStandard;
  }
  //
  //Check generic parameters
  //
  //Override defaults in special modes
  if (0 != (hv_Mode==hv_MODE_GRID))
  {
    hv_DisplayCenter = 1;
    hv_DisplayCircle = 0;
    hv_DisplayLegend = 0;
    hv_MaxGrade = 4;
    if (0 != ((hv_Color.TupleLength())==0))
    {
      hv_Color = "gray";
    }
  }
  else if (0 != (hv_Mode==hv_MODE_BAD))
  {
    hv_DisplayCenter = 0;
    hv_DisplayCircle = 1;
    hv_DisplayLegend = 0;
    hv_MaxGrade = 0;
  }
  //
  if (0 != ((hv_GenParamName.TupleLength())!=(hv_GenParamValue.TupleLength())))
  {
    //Check if number of values matches number of parameters
    throw HException("GenParamName and GenParamValue do not match.");
  }
  else
  {
    //Set generic parameters
    {
    HTuple end_val59 = (hv_GenParamName.TupleLength())-1;
    HTuple step_val59 = 1;
    for (hv_I=0; hv_I.Continue(end_val59, step_val59); hv_I += step_val59)
    {
      //'center'
      if (0 != (HTuple(hv_GenParamName[hv_I])==hv_GEN_CENTER))
      {
        //Check if values are valid
        if (0 != (HTuple(HTuple(hv_GenParamValue[hv_I])!=HTuple("true")).TupleAnd(HTuple(hv_GenParamValue[hv_I])!=HTuple("false"))))
        {
          throw HException(("Wrong parameter value for generic parameter 'center': "+HTuple(hv_GenParamValue[hv_I]))+" Please use 'true' or 'false'.");
        }
        //Set new value
        hv_DisplayCenter = HTuple(hv_GenParamValue[hv_I])==HTuple("true");
        //'circle'
      }
      else if (0 != (HTuple(hv_GenParamName[hv_I])==hv_GEN_CIRCLE))
      {
        //Check if values are valid
        if (0 != (HTuple(HTuple(hv_GenParamValue[hv_I])!=HTuple("true")).TupleAnd(HTuple(hv_GenParamValue[hv_I])!=HTuple("false"))))
        {
          throw HException(("Wrong parameter value for generic parameter 'circle': "+HTuple(hv_GenParamValue[hv_I]))+" Please use 'true' or 'false'.");
        }
        //Set new value
        hv_DisplayCircle = HTuple(hv_GenParamValue[hv_I])==HTuple("true");
      }
      else if (0 != (HTuple(hv_GenParamName[hv_I])==hv_GEN_LEGEND))
      {
        //Check if values are valid
        if (0 != (HTuple(HTuple(hv_GenParamValue[hv_I])!=HTuple("true")).TupleAnd(HTuple(hv_GenParamValue[hv_I])!=HTuple("false"))))
        {
          throw HException(("Wrong parameter value for generic parameter 'legend': "+HTuple(hv_GenParamValue[hv_I]))+" Please use 'true' or 'false'.");
        }
        //Set new value
        hv_DisplayLegend = HTuple(hv_GenParamValue[hv_I])==HTuple("true");
      }
      else if (0 != (HTuple(hv_GenParamName[hv_I])==hv_GEN_MAX_GRADE))
      {
        //Check if values are valid
        if (0 != (HTuple(HTuple(hv_GenParamValue[hv_I])<0).TupleOr(HTuple(hv_GenParamValue[hv_I])>4)))
        {
          throw HException(("Wrong parameter value for generic parameter 'max_grade': "+HTuple(hv_GenParamValue[hv_I]))+" Please use a value between 0 and 4.");
        }
        //Set new value
        hv_MaxGrade = HTuple(hv_GenParamValue[hv_I]).TupleInt();
      }
      else
      {
        //Unknown parameter
        throw HException("Unknown generic parameter: '"+HTuple(hv_GenParamName[hv_I]));
      }
    }
    }
  }
  //
  //Check Color
  if (0 != ((hv_Color.TupleLength())==0))
  {
    hv_Color.Clear();
    hv_Color[0] = "red";
    hv_Color[1] = "orange";
    hv_Color[2] = "yellow";
    hv_Color[3] = "cyan";
    hv_Color[4] = "green";
  }
  //Build color tuple with rotating colors if too few colors are specified
  while (0 != ((hv_Color.TupleLength())<(hv_MaxGrade+1)))
  {
    hv_Color = hv_Color.TupleConcat(hv_Color);
  }
  //
  //Visualization
  //
  //Get modulation grades, rows and cols for all symbol modules incl.
  //the 4 quiet zones adjacent to the symbol and the finder patterns.
  hv_QualityParameter = hv_QualityStandard+"_reflectance_margin_module_grades";
  hv_QualityRows = hv_QualityStandard+"_rows";
  hv_QualityCols = hv_QualityStandard+"_cols";
  GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, hv_QualityParameter, &hv_ModuleGrades);
  GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, hv_QualityRows, &hv_Rows);
  GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, hv_QualityCols, &hv_Cols);
  hv_QualityLabels = hv_QualityStandard+"_labels";
  GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, hv_QualityStandard, &hv_Grades);
  GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, hv_QualityLabels, &hv_Labels);
  GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, "module_height", &hv_ModuleHeight);
  GetDataCode2dResults(hv_DataCodeHandle, hv_ResultHandle, "module_width", &hv_ModuleWidth);
  hv_Aperture = HTuple(hv_Grades[hv_Labels.TupleFind("Aperture")]);
  hv_Radius = (0.5*hv_Aperture)*(hv_ModuleHeight.TupleMin2(hv_ModuleWidth));
  //
  //Iterate over all possible modulation grades to visualize
  {
  HTuple end_val125 = hv_MaxGrade;
  HTuple step_val125 = 1;
  for (hv_Grade=0; hv_Grade.Continue(end_val125, step_val125); hv_Grade += step_val125)
  {
    hv_GradeIdx = hv_ModuleGrades.TupleFind(hv_Grade);
    if (0 != (hv_GradeIdx<0))
    {
      continue;
    }
    hv_GradeRows = HTuple(hv_Rows[hv_GradeIdx]);
    hv_GradeCols = HTuple(hv_Cols[hv_GradeIdx]);
    hv_GradeRadius = HTuple(hv_GradeRows.TupleLength(),hv_Radius);
    if (HDevWindowStack::IsOpen())
      SetColor(HDevWindowStack::GetActive(),HTuple(hv_Color[hv_Grade]));
    if (0 != hv_DisplayCircle)
    {
      GenCircleContourXld(&ho_Circle, hv_GradeRows, hv_GradeCols, hv_GradeRadius, 
          HTuple(0).TupleRad(), HTuple(360).TupleRad(), "positive", 1);
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Circle, HDevWindowStack::GetActive());
    }
    if (0 != hv_DisplayCenter)
    {
      GenCrossContourXld(&ho_Cross, hv_GradeRows, hv_GradeCols, 2*hv_Radius, HTuple(0).TupleRad());
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Cross, HDevWindowStack::GetActive());
    }
  }
  }
  if (0 != hv_DisplayLegend)
  {
    //Display legend with modulation grades
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),HTuple("Reflectance Margin").TupleConcat("Module Grade "+HTuple::TupleGenSequence(0,hv_MaxGrade,1)), 
          "window", "bottom", "left", HTuple("white").TupleConcat(hv_Color), "box_color", 
          "#00000080");
  }
  return;
}
