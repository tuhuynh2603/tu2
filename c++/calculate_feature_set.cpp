///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 13.0.2.2
///////////////////////////////////////////////////////////////////////////////




#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#endif



using namespace HalconCpp;

// Procedure declarations 
// Chapter: Classification / Misc
// Short Description: Describe and calculate user-defined features to be used in conjunction with the calculate_feature_set procedure library. 
extern void get_custom_features (HObject ho_Region, HObject ho_Image, HTuple hv_CurrentName, 
    HTuple hv_Mode, HTuple *hv_Output);
// Chapter: Classification / Misc
// Short Description: Auxiliary procedure for get_custom_features and get_features. 
void append_length_or_values (HTuple hv_Mode, HTuple hv_Feature, HTuple hv_AccumulatedResults, 
    HTuple *hv_ExtendedResults);
// Chapter: Classification / Misc
// Short Description: Auxiliary procedure for get_custom_features and get_features. 
void append_names_or_groups (HTuple hv_Mode, HTuple hv_Name, HTuple hv_Groups, HTuple hv_CurrentName, 
    HTuple hv_AccumulatedResults, HTuple *hv_ExtendedResults);
// Chapter: Classification / Misc
// Short Description: Returns the length of the feature vector for each feature name. 
void get_feature_lengths (HTuple hv_FeatureNames, HTuple *hv_Lengths);
// Chapter: Classification / Misc
// Short Description: List all available feature group names. 
void query_feature_group_names (HTuple *hv_GroupNames);
// Chapter: Classification / Misc
// Short Description: Test procedure for custom features. 
void test_features (HTuple hv_FeatureNames);
// Chapter: Classification / Misc
// Short Description: Returns a table of feature names sorted by groups. 
void query_feature_names_by_group (HTuple hv_GroupNames, HTuple *hv_FeatureNames, 
    HTuple *hv_Groups);
// Chapter: Classification / Misc
// Short Description: Calculate color intensity features. 
void calc_feature_color_intensity (HObject ho_Region, HObject ho_Image, HTuple hv_ColorSpace, 
    HTuple hv_Mode, HTuple *hv_Feature);
// Chapter: Classification / Misc
// Short Description: Returns a list of feature names that belong to the feature groups given in GroupNames. 
void get_feature_names (HTuple hv_GroupNames, HTuple *hv_Names);
// Chapter: Classification / Misc
// Short Description: This procedure contains all relevant information about the supported features. 
void get_features (HObject ho_Region, HObject ho_Image, HTuple hv_Namelist, HTuple hv_Mode, 
    HTuple *hv_Output);
// Chapter: Classification / Misc
// Short Description: Auxiliary procedure for get_features. 
void append_names_or_groups_pyramid (HTuple hv_Mode, HTuple hv_Groups, HTuple hv_CurrentName, 
    HTuple hv_Names, HTuple hv_NameRegExp, HTuple hv_AccumulatedResults, HTuple *hv_ExtendedResults);
// Chapter: Classification / Misc
// Short Description: Calculate a feature on different image pyramid levels. 
void calc_feature_pyramid (HObject ho_Region, HObject ho_Image, HTuple hv_FeatureName, 
    HTuple hv_NumLevels, HTuple *hv_Feature);
// Chapter: Classification / Misc
// Short Description: Calculate gray-value projections and their histograms. 
void calc_feature_gray_proj (HObject ho_Region, HObject ho_Image, HTuple hv_Mode, 
    HTuple hv_Size, HTuple *hv_Feature);
// Chapter: Classification / Misc
// Short Description: Calculate one or more features of a given image and/or region. 
void calculate_features (HObject ho_Region, HObject ho_Image, HTuple hv_FeatureNames, 
    HTuple *hv_Features);
// Chapter: Classification / Misc
// Short Description: Calculate edge density histogram feature. 
void calc_feature_edge_density_histogram (HObject ho_Region, HObject ho_Image, HTuple hv_NumBins, 
    HTuple *hv_Feature);
// Chapter: Classification / Misc
// Short Description: Calculate the gradient direction histogram. 
void calc_feature_grad_dir_histo (HObject ho_Region, HObject ho_Image, HTuple hv_NumBins, 
    HTuple *hv_Feature);
// Chapter: Classification / Misc
// Short Description: Generate a dummy image and region that are, e.g., used to determine the lengths of the feature vectors in get_feature_lengths. 
void gen_dummy_objects (HObject *ho_Region, HObject *ho_Image);
// Chapter: Classification / Misc
// Short Description: Calculate edge density. 
void calc_feature_edge_density (HObject ho_Region, HObject ho_Image, HTuple *hv_Feature);
// Chapter: Classification / Misc
// Short Description: Calculate gray-value projections of polar-transformed image regions. 
void calc_feature_polar_gray_proj (HObject ho_Region, HObject ho_Image, HTuple hv_Mode, 
    HTuple hv_Width, HTuple hv_Height, HTuple *hv_Features);

// Procedures 
// Chapter: Classification / Misc
// Short Description: Auxiliary procedure for get_custom_features and get_features. 
void append_length_or_values (HTuple hv_Mode, HTuple hv_Feature, HTuple hv_AccumulatedResults, 
    HTuple *hv_ExtendedResults)
{

  // Local iconic variables

  //
  //Auxiliary procedure used only by get_features and get_custom_features
  //
  if (0 != (hv_Mode==HTuple("get_lengths")))
  {
    //Output in 'get_lengths' mode is the length of the feature
    (*hv_ExtendedResults).Clear();
    (*hv_ExtendedResults).Append(hv_AccumulatedResults);
    (*hv_ExtendedResults).Append(hv_Feature.TupleLength());
  }
  else if (0 != (hv_Mode==HTuple("calculate")))
  {
    //Output in 'calculate' mode is the feature vector
    (*hv_ExtendedResults).Clear();
    (*hv_ExtendedResults).Append(hv_AccumulatedResults);
    (*hv_ExtendedResults).Append(hv_Feature);
  }
  else
  {
    (*hv_ExtendedResults) = hv_AccumulatedResults;
  }
  return;
}

// Chapter: Classification / Misc
// Short Description: Auxiliary procedure for get_custom_features and get_features. 
void append_names_or_groups (HTuple hv_Mode, HTuple hv_Name, HTuple hv_Groups, HTuple hv_CurrentName, 
    HTuple hv_AccumulatedResults, HTuple *hv_ExtendedResults)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_FirstOccurrence, hv_BelongsToGroup;

  //
  //Auxiliary procedure used only by get_features and get_custom_features
  //
  (*hv_ExtendedResults) = hv_AccumulatedResults;
  if (0 != (hv_Mode==HTuple("get_names")))
  {
    hv_FirstOccurrence = HTuple((hv_AccumulatedResults.TupleLength())==0).TupleOr((hv_AccumulatedResults.TupleFind(hv_Name))==-1);
    hv_BelongsToGroup = HTuple(((hv_Name.TupleConcat(hv_Groups)).TupleFind(hv_CurrentName))!=-1).TupleOr(hv_CurrentName==HTuple("all"));
    if (0 != (hv_FirstOccurrence.TupleAnd(hv_BelongsToGroup)))
    {
      //Output in 'get_names' mode is the name of the feature
      (*hv_ExtendedResults).Clear();
      (*hv_ExtendedResults).Append(hv_AccumulatedResults);
      (*hv_ExtendedResults).Append(hv_Name);
    }
  }
  else if (0 != (hv_Mode==HTuple("get_groups")))
  {
    (*hv_ExtendedResults).Clear();
    (*hv_ExtendedResults).Append(hv_AccumulatedResults);
    (*hv_ExtendedResults).Append(hv_Groups);
  }
  return;
}

// Chapter: Classification / Misc
// Short Description: Returns the length of the feature vector for each feature name. 
void get_feature_lengths (HTuple hv_FeatureNames, HTuple *hv_Lengths)
{

  // Local iconic variables
  HObject  ho_Region, ho_Image;

  //
  //Calculate the lengths of the feature vectors of
  //the features in FeatureNames.
  //
  gen_dummy_objects(&ho_Region, &ho_Image);
  get_features(ho_Region, ho_Image, hv_FeatureNames, "get_lengths", &(*hv_Lengths));
  return;
}

// Chapter: Classification / Misc
// Short Description: List all available feature group names. 
void query_feature_group_names (HTuple *hv_GroupNames)
{

  // Local iconic variables
  HObject  ho_Region, ho_Image;

  //
  //Return all available feature groups
  //
  gen_dummy_objects(&ho_Region, &ho_Image);
  get_features(ho_Region, ho_Image, "", "get_groups", &(*hv_GroupNames));
  (*hv_GroupNames) = ((*hv_GroupNames).TupleSort()).TupleUniq();
  (*hv_GroupNames) = (*hv_GroupNames).TupleConcat("all");
  return;
}

// Chapter: Classification / Misc
// Short Description: Test procedure for custom features. 
void test_features (HTuple hv_FeatureNames)
{

  // Local iconic variables
  HObject  ho_Image, ho_Region, ho_TestRegion, ho_TestRegionSelected;
  HObject  ho_ObjectSelected;

  // Local control variables
  HTuple  hv_TestSuccessful, hv_TestString, hv_Test;
  HTuple  hv_NumRegions, hv_AllFeatures, hv_Index, hv_CurName;
  HTuple  hv_Lengths, hv_CurLength, hv_Features, hv_SumLengths;
  HTuple  hv_Total, hv_I, hv_Features2, hv_J, hv_Features1;
  HTuple  hv_CorrectOrder;

  //
  //Test procedure for custom features
  //
  //This procedure can be used to test, if custom features
  //implemented in get_custom_features comply with the
  //specifications of the calculate_feature_set library.
  //
  //In particular, the feature vector Feature, that is
  //calculated with calculate_feature must fulfil
  //following conditions:
  //
  //- For a single input region the result of
  //  get_feature_length has to be equal to the length
  //  of the featue vector: |Feature| == Length
  //
  //- For an empty input region array, the feature
  //  vector has to be empty:
  //  Feature == []
  //
  //- For input region arrays with multiple regions, the
  //  following condition must be met:
  //  |Feature| == NumRegions * Length
  //
  //- Additionally, the feature vector has to be sorted
  //  according to the 'feature_column' order of
  //  add_sample_class_train_data.
  //
  hv_TestSuccessful = 0;
  ReadImage(&ho_Image, "patras");
  Threshold(ho_Image, &ho_Region, 128, 255);
  get_feature_lengths(hv_FeatureNames, &hv_Lengths);
  //
  hv_TestString[0] = "Empty region array test (no region)";
  hv_TestString[1] = "Empty region test";
  hv_TestString[2] = "Single region test";
  for (hv_Test=0; hv_Test<=2; hv_Test+=1)
  {
    switch (hv_Test.I())
    {
    case 0:
      SelectShape(ho_Region, &ho_TestRegion, "area", "and", 0, 0);
      break;
    case 1:
      GenEmptyRegion(&ho_TestRegion);
      break;
    case 2:
      CopyObj(ho_Region, &ho_TestRegion, 1, 1);
      break;
    default:
      ;
    }
    CountObj(ho_TestRegion, &hv_NumRegions);
    hv_AllFeatures = HTuple();
    {
    HTuple end_val50 = (hv_FeatureNames.TupleLength())-1;
    HTuple step_val50 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val50, step_val50); hv_Index += step_val50)
    {
      hv_CurName = HTuple(hv_FeatureNames[hv_Index]);
      hv_CurLength = HTuple(hv_Lengths[hv_Index]);
      calculate_features(ho_TestRegion, ho_Image, hv_CurName, &hv_Features);
      if (0 != ((hv_NumRegions*hv_CurLength)!=(hv_Features.TupleLength())))
      {
        throw HException(((HTuple(hv_TestString[hv_Test])+" failed for feature '")+hv_CurName)+"'");
      }
      hv_AllFeatures = hv_AllFeatures.TupleConcat(hv_Features);
    }
    }
    hv_SumLengths = hv_Lengths.TupleSum();
    hv_Total = hv_SumLengths*hv_NumRegions;
    if (0 != (hv_Total!=(hv_AllFeatures.TupleLength())))
    {
      throw HException((("Test "+hv_Test)+" failed").TupleConcat(HTuple(hv_TestString[hv_Test])));
    }
  }
  //
  //Test multiple input regions
  Connection(ho_Region, &ho_TestRegion);
  SelectObj(ho_TestRegion, &ho_TestRegionSelected, HTuple::TupleGenSequence(1,3,1));
  {
  HTuple end_val69 = (hv_FeatureNames.TupleLength())-1;
  HTuple step_val69 = 1;
  for (hv_I=0; hv_I.Continue(end_val69, step_val69); hv_I += step_val69)
  {
    hv_CurName = HTuple(hv_FeatureNames[hv_I]);
    calculate_features(ho_TestRegionSelected, ho_Image, hv_CurName, &hv_Features1);
    hv_Features2 = HTuple();
    CountObj(ho_TestRegionSelected, &hv_NumRegions);
    {
    HTuple end_val74 = hv_NumRegions;
    HTuple step_val74 = 1;
    for (hv_J=1; hv_J.Continue(end_val74, step_val74); hv_J += step_val74)
    {
      SelectObj(ho_TestRegionSelected, &ho_ObjectSelected, hv_J);
      calculate_features(ho_ObjectSelected, ho_Image, hv_CurName, &hv_Features);
      hv_Features2 = hv_Features2.TupleConcat(hv_Features);
    }
    }
    hv_CorrectOrder = hv_Features1==hv_Features2;
    if (0 != (hv_CorrectOrder.TupleNot()))
    {
      throw HException(("Multiple region test failed for feature '"+hv_CurName)+"'");
    }
  }
  }
  hv_TestSuccessful = 1;
  return;
}

// Chapter: Classification / Misc
// Short Description: Returns a table of feature names sorted by groups. 
void query_feature_names_by_group (HTuple hv_GroupNames, HTuple *hv_FeatureNames, 
    HTuple *hv_Groups)
{

  // Local iconic variables
  HObject  ho_Region, ho_Image;

  // Local control variables
  HTuple  hv_I, hv_Names;

  //
  //Return a table (consisting of two tuples)
  //of all features and the groups they belong to.
  //
  (*hv_FeatureNames) = HTuple();
  (*hv_Groups) = HTuple();
  gen_dummy_objects(&ho_Region, &ho_Image);
  {
  HTuple end_val7 = (hv_GroupNames.TupleLength())-1;
  HTuple step_val7 = 1;
  for (hv_I=0; hv_I.Continue(end_val7, step_val7); hv_I += step_val7)
  {
    get_features(ho_Region, ho_Image, HTuple(hv_GroupNames[hv_I]), "get_names", &hv_Names);
    (*hv_FeatureNames) = (*hv_FeatureNames).TupleConcat(hv_Names);
    (*hv_Groups) = (*hv_Groups).TupleConcat(HTuple(hv_Names.TupleLength(),HTuple(hv_GroupNames[hv_I])));
  }
  }
  return;
}

// Chapter: Classification / Misc
// Short Description: Calculate color intensity features. 
void calc_feature_color_intensity (HObject ho_Region, HObject ho_Image, HTuple hv_ColorSpace, 
    HTuple hv_Mode, HTuple *hv_Feature)
{

  // Local iconic variables
  HObject  ho_R, ho_G, ho_B, ho_I1, ho_I2, ho_I3;

  // Local control variables
  HTuple  hv_Channels, hv_Mean1, hv_Deviation1;
  HTuple  hv_Mean2, hv_Deviation2, hv_Mean3, hv_Deviation3;
  HTuple  hv_Tmp1, hv_Tmp2, hv_Tmp3, hv_NumRegions, hv_Index;

  //
  //Calculate color features
  //
  //Transform an RGB image into the given ColorSpace
  //and calculate the mean gray value and the deviation
  //for all three channels.
  //
  CountChannels(ho_Image, &hv_Channels);
  if (0 != (hv_Channels!=3))
  {
    throw HException(((("Error when calculating feature "+hv_ColorSpace)+"_")+hv_Mode).TupleConcat("Please use a 3-channel RGB image or remove color feature from the list."));
  }
  Decompose3(ho_Image, &ho_R, &ho_G, &ho_B);
  if (0 != (hv_ColorSpace==HTuple("rgb")))
  {
    Intensity(ho_Region, ho_R, &hv_Mean1, &hv_Deviation1);
    Intensity(ho_Region, ho_G, &hv_Mean2, &hv_Deviation2);
    Intensity(ho_Region, ho_B, &hv_Mean3, &hv_Deviation3);
  }
  else
  {
    TransFromRgb(ho_R, ho_G, ho_B, &ho_I1, &ho_I2, &ho_I3, hv_ColorSpace);
    Intensity(ho_Region, ho_I1, &hv_Mean1, &hv_Deviation1);
    Intensity(ho_Region, ho_I2, &hv_Mean2, &hv_Deviation2);
    Intensity(ho_Region, ho_I3, &hv_Mean3, &hv_Deviation3);
  }
  if (0 != (hv_Mode==HTuple("mean")))
  {
    hv_Tmp1 = hv_Mean1;
    hv_Tmp2 = hv_Mean2;
    hv_Tmp3 = hv_Mean3;
  }
  else if (0 != (hv_Mode==HTuple("deviation")))
  {
    hv_Tmp1 = hv_Deviation1;
    hv_Tmp2 = hv_Deviation2;
    hv_Tmp3 = hv_Deviation3;
  }
  CountObj(ho_Region, &hv_NumRegions);
  if (0 != (hv_NumRegions>0))
  {
    hv_Index = HTuple::TupleGenSequence(0,(3*hv_NumRegions)-1,3);
    (*hv_Feature)[hv_Index] = hv_Tmp1;
    (*hv_Feature)[1+hv_Index] = hv_Tmp2;
    (*hv_Feature)[2+hv_Index] = hv_Tmp3;
  }
  else
  {
    (*hv_Feature) = HTuple();
  }
  return;
}

// Chapter: Classification / Misc
// Short Description: Returns a list of feature names that belong to the feature groups given in GroupNames. 
void get_feature_names (HTuple hv_GroupNames, HTuple *hv_Names)
{

  // Local iconic variables
  HObject  ho_Region, ho_Image;

  //
  //Return all features that belong to
  //at least one of the groups in GroupNames
  //
  gen_dummy_objects(&ho_Region, &ho_Image);
  get_features(ho_Region, ho_Image, hv_GroupNames, "get_names", &(*hv_Names));
  return;
}

// Chapter: Classification / Misc
// Short Description: This procedure contains all relevant information about the supported features. 
void get_features (HObject ho_Region, HObject ho_Image, HTuple hv_Namelist, HTuple hv_Mode, 
    HTuple *hv_Output)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_EmptyRegionResult, hv_AccumulatedResults;
  HTuple  hv_CustomResults, hv_NumRegions, hv_ImageWidth;
  HTuple  hv_ImageHeight, hv_I, hv_CurrentName, hv_Name, hv_Groups;
  HTuple  hv_Feature, hv_ExpDefaultCtrlDummyVar, hv_ExtendedResults;
  HTuple  hv_Row1, hv_Column1, hv_Row2, hv_Column2, hv_Ra;
  HTuple  hv_Rb, hv_Phi, hv_Distance, hv_Sigma, hv_Roundness;
  HTuple  hv_Sides, hv_NumConnected, hv_NumHoles, hv_Diameter;
  HTuple  hv_Row, hv_Column, hv_Anisometry, hv_Bulkiness;
  HTuple  hv_StructureFactor, hv_Length1, hv_Length2, hv_ContLength;
  HTuple  hv_AreaHoles, hv_Area, hv_Min, hv_Max, hv_Range;
  HTuple  hv_Mean, hv_Deviation, hv_Entropy, hv_Anisotropy;
  HTuple  hv_Size, hv_NumBins, hv_NameRegExp, hv_Names, hv_NumPyramids;
  HTuple  hv_Energy, hv_Correlation, hv_Homogeneity, hv_Contrast;
  HTuple  hv_Index, hv_Width, hv_Height, hv_Projection, hv_Start;
  HTuple  hv_Histo, hv_BinSize;

  //*********************************************************
  //Feature procedure
  //Contains the names, properties and calculation of
  //all supproted features.
  //It consists of similar blocks for each feature.
  //
  //If you like to add your own features, please use
  //the external procedure get_custom_features.hdvp
  //in the HALCON procedures/templates directory.
  //*********************************************************
  //
  //Insert location of your custom procedure here
  //
  GetSystem("empty_region_result", &hv_EmptyRegionResult);
  SetSystem("empty_region_result", "true");
  hv_AccumulatedResults = HTuple();
  hv_CustomResults = HTuple();
  CountObj(ho_Region, &hv_NumRegions);
  GetImageSize(ho_Image, &hv_ImageWidth, &hv_ImageHeight);
  //
  {
  HTuple end_val20 = (hv_Namelist.TupleLength())-1;
  HTuple step_val20 = 1;
  for (hv_I=0; hv_I.Continue(end_val20, step_val20); hv_I += step_val20)
  {
    hv_CurrentName = HTuple(hv_Namelist[hv_I]);
    //
    get_custom_features(ho_Region, ho_Image, hv_CurrentName, hv_Mode, &hv_CustomResults);
    hv_AccumulatedResults = hv_AccumulatedResults.TupleConcat(hv_CustomResults);
    //
    //
    //************************************
    //HALCON REGION FEATURES
    //************************************
    //
    //************************************
    //BASIC
    //************************************
    //** area ***
    hv_Name = "area";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      AreaCenter(ho_Region, &hv_Feature, &hv_ExpDefaultCtrlDummyVar, &hv_ExpDefaultCtrlDummyVar);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** width ***
    hv_Name = "width";
    hv_Groups = "region";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      SmallestRectangle1(ho_Region, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
      hv_Feature = (hv_Column2-hv_Column1)+1;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** height ***
    hv_Name = "height";
    hv_Groups = "region";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      SmallestRectangle1(ho_Region, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
      hv_Feature = (hv_Row2-hv_Row1)+1;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** ra ***
    hv_Name = "ra";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      EllipticAxis(ho_Region, &hv_Ra, &hv_Rb, &hv_Phi);
      hv_Feature = hv_Ra;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** rb ***
    hv_Name = "rb";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      EllipticAxis(ho_Region, &hv_Ra, &hv_Rb, &hv_Phi);
      hv_Feature = hv_Rb;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** phi ***
    hv_Name = "phi";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      EllipticAxis(ho_Region, &hv_Ra, &hv_Rb, &hv_Phi);
      hv_Feature = hv_Phi;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** roundness ***
    hv_Name = "roundness";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      Roundness(ho_Region, &hv_Distance, &hv_Sigma, &hv_Roundness, &hv_Sides);
      hv_Feature = hv_Roundness;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** num_sides ***
    hv_Name = "num_sides";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      Roundness(ho_Region, &hv_Distance, &hv_Sigma, &hv_Roundness, &hv_Sides);
      hv_Feature = hv_Sides;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** num_connected ***
    hv_Name = "num_connected";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      ConnectAndHoles(ho_Region, &hv_NumConnected, &hv_NumHoles);
      hv_Feature = hv_NumConnected;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** num_holes ***
    hv_Name = "num_holes";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      ConnectAndHoles(ho_Region, &hv_NumConnected, &hv_NumHoles);
      hv_Feature = hv_NumHoles;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** area_holes ***
    hv_Name = "area_holes";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      AreaHoles(ho_Region, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** max_diameter ***
    hv_Name = "max_diameter";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      DiameterRegion(ho_Region, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2, &hv_Diameter);
      hv_Feature = hv_Diameter;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** orientation ***
    hv_Name = "orientation";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      OrientationRegion(ho_Region, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //SHAPE
    //************************************
    //
    //************************************
    //** outer_radius ***
    hv_Name = "outer_radius";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      SmallestCircle(ho_Region, &hv_Row, &hv_Column, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** inner_radius ***
    hv_Name = "inner_radius";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      InnerCircle(ho_Region, &hv_Row, &hv_Column, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** inner_width ***
    hv_Name = "inner_width";
    hv_Groups = "region";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      InnerRectangle1(ho_Region, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
      hv_Feature = (hv_Column2-hv_Column1)+1;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** inner_height ***
    hv_Name = "inner_height";
    hv_Groups = "region";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      InnerRectangle1(ho_Region, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
      hv_Feature = (hv_Row2-hv_Row1)+1;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** circularity ***
    hv_Name = "circularity";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      Circularity(ho_Region, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** compactness ***
    hv_Name = "compactness";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      Compactness(ho_Region, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** convexity ***
    hv_Name = "convexity";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      Convexity(ho_Region, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** rectangularity ***
    hv_Name = "rectangularity";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      Rectangularity(ho_Region, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** anisometry ***
    hv_Name = "anisometry";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      Eccentricity(ho_Region, &hv_Anisometry, &hv_Bulkiness, &hv_StructureFactor);
      hv_Feature = hv_Anisometry;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** bulkiness ***
    hv_Name = "bulkiness";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      Eccentricity(ho_Region, &hv_Anisometry, &hv_Bulkiness, &hv_StructureFactor);
      hv_Feature = hv_Bulkiness;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** struct_factor ***
    hv_Name = "struct_factor";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      Eccentricity(ho_Region, &hv_Anisometry, &hv_Bulkiness, &hv_StructureFactor);
      hv_Feature = hv_StructureFactor;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** dist_mean ***
    hv_Name = "dist_mean";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      Roundness(ho_Region, &hv_Distance, &hv_Sigma, &hv_Roundness, &hv_Sides);
      hv_Feature = hv_Distance;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** dist_deviation ***
    hv_Name = "dist_deviation";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      Roundness(ho_Region, &hv_Distance, &hv_Sigma, &hv_Roundness, &hv_Sides);
      hv_Feature = hv_Sigma;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** euler_number ***
    hv_Name = "euler_number";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      EulerNumber(ho_Region, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** rect2_phi ***
    hv_Name = "rect2_phi";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      SmallestRectangle2(ho_Region, &hv_Row, &hv_Column, &hv_Phi, &hv_Length1, &hv_Length2);
      hv_Feature = hv_Phi;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** rect2_len1 ***
    hv_Name = "rect2_len1";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      SmallestRectangle2(ho_Region, &hv_Row, &hv_Column, &hv_Phi, &hv_Length1, &hv_Length2);
      hv_Feature = hv_Length1;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** rect2_len2 ***
    hv_Name = "rect2_len2";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      SmallestRectangle2(ho_Region, &hv_Row, &hv_Column, &hv_Phi, &hv_Length1, &hv_Length2);
      hv_Feature = hv_Length2;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** contlength ***
    hv_Name = "contlength";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      Contlength(ho_Region, &hv_ContLength);
      hv_Feature = hv_ContLength;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //REGION FEATURES
    //************************************
    //MISC
    //************************************
    //** porosity ***
    hv_Name = "porosity";
    hv_Groups.Clear();
    hv_Groups[0] = "region";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      AreaHoles(ho_Region, &hv_AreaHoles);
      AreaCenter(ho_Region, &hv_Area, &hv_Row, &hv_Column);
      if (0 != (hv_Area==0))
      {
        hv_Feature = 0.0;
      }
      else
      {
        hv_Feature = (hv_AreaHoles.TupleReal())/(hv_Area+hv_AreaHoles);
      }
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //HALCON GRAY VALUE FEATURES
    //************************************
    //BASIC
    //************************************
    //
    //** gray_area ***
    hv_Name = "gray_area";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "rot_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      AreaCenterGray(ho_Region, ho_Image, &hv_Area, &hv_Row, &hv_Column);
      hv_Feature = hv_Area;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** gray_ra ***
    hv_Name = "gray_ra";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "rot_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      EllipticAxisGray(ho_Region, ho_Image, &hv_Ra, &hv_Rb, &hv_Phi);
      hv_Feature = hv_Ra;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** gray_rb ***
    hv_Name = "gray_rb";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "rot_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      EllipticAxisGray(ho_Region, ho_Image, &hv_Ra, &hv_Rb, &hv_Phi);
      hv_Feature = hv_Rb;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** gray_phi ***
    hv_Name = "gray_phi";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      EllipticAxisGray(ho_Region, ho_Image, &hv_Ra, &hv_Rb, &hv_Phi);
      hv_Feature = hv_Phi;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** gray_min ***
    hv_Name = "gray_min";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      MinMaxGray(ho_Region, ho_Image, 0, &hv_Min, &hv_Max, &hv_Range);
      hv_Feature = hv_Min;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** gray_max ***
    hv_Name = "gray_max";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      MinMaxGray(ho_Region, ho_Image, 0, &hv_Min, &hv_Max, &hv_Range);
      hv_Feature = hv_Max;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** gray_range ***
    hv_Name = "gray_range";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      MinMaxGray(ho_Region, ho_Image, 0, &hv_Min, &hv_Max, &hv_Range);
      hv_Feature = hv_Range;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //TEXTURE
    //************************************
    //
    //************************************
    //** gray_mean ***
    hv_Name = "gray_mean";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    hv_Groups[2] = "rot_invar";
    hv_Groups[3] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      Intensity(ho_Region, ho_Image, &hv_Mean, &hv_Deviation);
      hv_Feature = hv_Mean;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** gray_deviation ***
    hv_Name = "gray_deviation";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    hv_Groups[2] = "rot_invar";
    hv_Groups[3] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      Intensity(ho_Region, ho_Image, &hv_Mean, &hv_Deviation);
      hv_Feature = hv_Deviation;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** gray_plane_deviation ***
    hv_Name = "gray_plane_deviation";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    hv_Groups[2] = "rot_invar";
    hv_Groups[3] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      PlaneDeviation(ho_Region, ho_Image, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** gray_anisotropy ***
    hv_Name = "gray_anisotropy";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    hv_Groups[2] = "rot_invar";
    hv_Groups[3] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      EntropyGray(ho_Region, ho_Image, &hv_Entropy, &hv_Anisotropy);
      hv_Feature = hv_Anisotropy;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** gray_entropy ***
    hv_Name = "gray_entropy";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    hv_Groups[2] = "rot_invar";
    hv_Groups[3] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      EntropyGray(ho_Region, ho_Image, &hv_Entropy, &hv_Anisotropy);
      hv_Feature = hv_Entropy;
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** gray_hor_proj ***
    hv_Name = "gray_hor_proj";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    hv_Groups[2] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      hv_Size = 20;
      calc_feature_gray_proj(ho_Region, ho_Image, "hor", hv_Size, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** gray_vert_proj ***
    hv_Name = "gray_vert_proj";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    hv_Groups[2] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      hv_Size = 20;
      calc_feature_gray_proj(ho_Region, ho_Image, "vert", hv_Size, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** gray_hor_proj_histo ***
    hv_Name = "gray_hor_proj_histo";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    hv_Groups[2] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      hv_Size = 20;
      calc_feature_gray_proj(ho_Region, ho_Image, "hor_histo", hv_Size, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** gray_vert_proj_histo ***
    hv_Name = "gray_vert_proj_histo";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    hv_Groups[2] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      hv_Size = 20;
      calc_feature_gray_proj(ho_Region, ho_Image, "vert_histo", hv_Size, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** grad_dir_histo ***
    hv_Name = "grad_dir_histo";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      hv_NumBins = 20;
      calc_feature_grad_dir_histo(ho_Region, ho_Image, hv_NumBins, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** edge_density ***
    hv_Name = "edge_density";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    hv_Groups[2] = "rot_invar";
    hv_Groups[3] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      calc_feature_edge_density(ho_Region, ho_Image, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** edge_density_histogram ***
    hv_Name = "edge_density_histogram";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    hv_Groups[2] = "rot_invar";
    hv_Groups[3] = "scale_invar";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      hv_NumBins = 4;
      calc_feature_edge_density_histogram(ho_Region, ho_Image, hv_NumBins, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** edge_density_pyramid ***
    hv_NameRegExp = "edge_density_pyramid_([234])";
    hv_Names = HTuple("edge_density_pyramid_")+HTuple::TupleGenSequence(2,4,1);
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    hv_Groups[2] = "rot_invar";
    hv_Groups[3] = "scale_invar";
    //****************
    if (0 != (hv_CurrentName.TupleRegexpTest(hv_NameRegExp)))
    {
      //** Calculate feature ***
      hv_NumPyramids = (hv_CurrentName.TupleRegexpMatch(hv_NameRegExp)).TupleNumber();
      calc_feature_pyramid(ho_Region, ho_Image, "edge_density", hv_NumPyramids, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups_pyramid(hv_Mode, hv_Groups, hv_CurrentName, hv_Names, 
        hv_NameRegExp, hv_AccumulatedResults, &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** edge_density_histogram_pyramid ***
    hv_NameRegExp = "edge_density_histogram_pyramid_([234])";
    hv_Names = HTuple("edge_density_histogram_pyramid_")+HTuple::TupleGenSequence(2,4,1);
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    hv_Groups[2] = "rot_invar";
    hv_Groups[3] = "scale_invar";
    //****************
    if (0 != (hv_CurrentName.TupleRegexpTest(hv_NameRegExp)))
    {
      //** Calculate feature ***
      hv_NumPyramids = (hv_CurrentName.TupleRegexpMatch(hv_NameRegExp)).TupleNumber();
      calc_feature_pyramid(ho_Region, ho_Image, "edge_density_histogram", hv_NumPyramids, 
          &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups_pyramid(hv_Mode, hv_Groups, hv_CurrentName, hv_Names, 
        hv_NameRegExp, hv_AccumulatedResults, &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //** cooc ***
    hv_Name = "cooc";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    //****************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      hv_Feature = HTuple();
      CoocFeatureImage(ho_Region, ho_Image, 6, 0, &hv_Energy, &hv_Correlation, &hv_Homogeneity, 
          &hv_Contrast);
      if (0 != (hv_NumRegions>0))
      {
        hv_Index = HTuple::TupleGenSequence(0,(4*hv_NumRegions)-1,4);
        hv_Feature[hv_Index] = hv_Energy;
        hv_Feature[1+hv_Index] = hv_Correlation;
        hv_Feature[2+hv_Index] = hv_Homogeneity;
        hv_Feature[3+hv_Index] = hv_Contrast;
      }
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** cooc_pyramid ***
    hv_NameRegExp = "cooc_pyramid_([234])";
    hv_Names = HTuple("cooc_pyramid_")+HTuple::TupleGenSequence(2,4,1);
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "texture";
    //****************
    if (0 != (hv_CurrentName.TupleRegexpTest(hv_NameRegExp)))
    {
      //** Calculate feature ***
      hv_NumPyramids = (hv_CurrentName.TupleRegexpMatch(hv_NameRegExp)).TupleNumber();
      calc_feature_pyramid(ho_Region, ho_Image, "cooc", hv_NumPyramids, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups_pyramid(hv_Mode, hv_Groups, hv_CurrentName, hv_Names, 
        hv_NameRegExp, hv_AccumulatedResults, &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //
    //************************************
    //
    //************************************
    //POLAR TRANSFORM FEATURES
    //************************************
    //
    //************************************
    //** polar_gray_proj ***
    hv_Name = "polar_gray_proj";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      hv_Width = 100;
      hv_Height = 40;
      calc_feature_polar_gray_proj(ho_Region, ho_Image, "hor_gray", hv_Width, hv_Height, 
          &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** polar_grad_proj ***
    hv_Name = "polar_grad_proj";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      hv_Width = 100;
      hv_Height = 40;
      calc_feature_polar_gray_proj(ho_Region, ho_Image, "hor_sobel_amp", hv_Width, 
          hv_Height, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** polar_grad_x_proj ***
    hv_Name = "polar_grad_x_proj";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      hv_Width = 100;
      hv_Height = 40;
      calc_feature_polar_gray_proj(ho_Region, ho_Image, "hor_sobel_x", hv_Width, 
          hv_Height, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** polar_grad_y_proj ***
    hv_Name = "polar_grad_y_proj";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      hv_Width = 100;
      hv_Height = 40;
      calc_feature_polar_gray_proj(ho_Region, ho_Image, "hor_sobel_y", hv_Width, 
          hv_Height, &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** polar_gray_proj_histo ***
    hv_Name = "polar_gray_proj_histo";
    hv_Groups.Clear();
    hv_Groups[0] = "gray";
    hv_Groups[1] = "rot_invar";
    hv_Groups[2] = "scale_invar";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      hv_Width = 100;
      hv_Height = 40;
      calc_feature_polar_gray_proj(ho_Region, ho_Image, "vert_gray", hv_Width, hv_Height, 
          &hv_Projection);
      hv_NumBins = 20;
      hv_Feature = HTuple();
      {
      HTuple end_val1093 = hv_NumRegions;
      HTuple step_val1093 = 1;
      for (hv_Index=1; hv_Index.Continue(end_val1093, step_val1093); hv_Index += step_val1093)
      {
        hv_Start = (hv_Index-1)*hv_Width;
        TupleHistoRange(hv_Projection.TupleSelectRange(hv_Start,(hv_Start+hv_Width)-1), 
            0, 255, hv_NumBins, &hv_Histo, &hv_BinSize);
        hv_Feature = hv_Feature.TupleConcat(hv_Histo);
      }
      }
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //COLOR FEATURES
    //************************************
    //
    //************************************
    //** cielab_mean ***
    hv_Name = "cielab_mean";
    hv_Groups = "color";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      calc_feature_color_intensity(ho_Region, ho_Image, "cielab", "mean", &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** cielab_dev ***
    hv_Name = "cielab_dev";
    hv_Groups = "color";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      calc_feature_color_intensity(ho_Region, ho_Image, "cielab", "deviation", &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** hls_mean ***
    hv_Name = "hls_mean";
    hv_Groups = "color";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      calc_feature_color_intensity(ho_Region, ho_Image, "hls", "mean", &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** hls_dev ***
    hv_Name = "hls_dev";
    hv_Groups = "color";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      calc_feature_color_intensity(ho_Region, ho_Image, "hls", "deviation", &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** rgb_mean ***
    hv_Name = "rgb_mean";
    hv_Groups = "color";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      calc_feature_color_intensity(ho_Region, ho_Image, "rgb", "mean", &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
    //************************************
    //
    //************************************
    //** rgb_dev ***
    hv_Name = "rgb_dev";
    hv_Groups = "color";
    //*************
    if (0 != (hv_Name==hv_CurrentName))
    {
      //** Calculate feature ***
      calc_feature_color_intensity(ho_Region, ho_Image, "rgb", "deviation", &hv_Feature);
      //*************************
      append_length_or_values(hv_Mode, hv_Feature, hv_AccumulatedResults, &hv_ExtendedResults);
      hv_AccumulatedResults = hv_ExtendedResults;
    }
    append_names_or_groups(hv_Mode, hv_Name, hv_Groups, hv_CurrentName, hv_AccumulatedResults, 
        &hv_ExtendedResults);
    hv_AccumulatedResults = hv_ExtendedResults;
  }
  }
  (*hv_Output) = hv_AccumulatedResults;
  SetSystem("empty_region_result", hv_EmptyRegionResult);
  return;
}

// Chapter: Classification / Misc
// Short Description: Auxiliary procedure for get_features. 
void append_names_or_groups_pyramid (HTuple hv_Mode, HTuple hv_Groups, HTuple hv_CurrentName, 
    HTuple hv_Names, HTuple hv_NameRegExp, HTuple hv_AccumulatedResults, HTuple *hv_ExtendedResults)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_BelongsToGroup, hv_TmpNames, hv_J;
  HTuple  hv_FirstOccurrence;

  //
  //Auxiliary procedure used only by get_features and get_custom_features
  //
  (*hv_ExtendedResults) = hv_AccumulatedResults;
  if (0 != (hv_Mode==HTuple("get_names")))
  {
    hv_BelongsToGroup = HTuple((hv_Groups.TupleFind(hv_CurrentName))!=-1).TupleOr(hv_CurrentName==HTuple("all"));
    if (0 != (hv_CurrentName.TupleRegexpTest(hv_NameRegExp)))
    {
      hv_Names = hv_CurrentName;
    }
    else if (0 != (hv_BelongsToGroup.TupleNot()))
    {
      hv_Names = HTuple();
    }
    hv_TmpNames = HTuple();
    {
    HTuple end_val12 = (hv_Names.TupleLength())-1;
    HTuple step_val12 = 1;
    for (hv_J=0; hv_J.Continue(end_val12, step_val12); hv_J += step_val12)
    {
      hv_FirstOccurrence = HTuple((hv_AccumulatedResults.TupleLength())==0).TupleOr((hv_AccumulatedResults.TupleFind(HTuple(hv_Names[hv_J])))==-1);
      if (0 != hv_FirstOccurrence)
      {
        //Output in 'get_names' mode is the name of the feature
        hv_TmpNames = hv_TmpNames.TupleConcat(HTuple(hv_Names[hv_J]));
      }
    }
    }
    (*hv_ExtendedResults).Clear();
    (*hv_ExtendedResults).Append(hv_AccumulatedResults);
    (*hv_ExtendedResults).Append(hv_TmpNames);
  }
  else if (0 != (hv_Mode==HTuple("get_groups")))
  {
    (*hv_ExtendedResults).Clear();
    (*hv_ExtendedResults).Append(hv_AccumulatedResults);
    (*hv_ExtendedResults).Append(hv_Groups);
  }
  return;
}

// Chapter: Classification / Misc
// Short Description: Calculate a feature on different image pyramid levels. 
void calc_feature_pyramid (HObject ho_Region, HObject ho_Image, HTuple hv_FeatureName, 
    HTuple hv_NumLevels, HTuple *hv_Feature)
{

  // Local iconic variables
  HObject  ho_ImageZoom, ho_RegionZoom;

  // Local control variables
  HTuple  hv_Zoom, hv_NumRegions, hv_I, hv_Features;
  HTuple  hv_FeatureLength, hv_Step, hv_Indices, hv_J, hv_Start;
  HTuple  hv_End;

  //
  //Calculate a feature for different pyramid levels
  //
  hv_Zoom = 0.5;
  (*hv_Feature) = HTuple();
  CountObj(ho_Region, &hv_NumRegions);
  if (0 != (hv_NumRegions>0))
  {
    {
    HTuple end_val7 = hv_NumLevels;
    HTuple step_val7 = 1;
    for (hv_I=1; hv_I.Continue(end_val7, step_val7); hv_I += step_val7)
    {
      if (0 != (hv_I>1))
      {
        ZoomImageFactor(ho_ImageZoom, &ho_ImageZoom, hv_Zoom, hv_Zoom, "constant");
        ZoomRegion(ho_RegionZoom, &ho_RegionZoom, hv_Zoom, hv_Zoom);
        calculate_features(ho_RegionZoom, ho_ImageZoom, hv_FeatureName, &hv_Features);
      }
      else
      {
        CopyObj(ho_Image, &ho_ImageZoom, 1, 1);
        CopyObj(ho_Region, &ho_RegionZoom, 1, hv_NumRegions);
        calculate_features(ho_RegionZoom, ho_ImageZoom, hv_FeatureName, &hv_Features);
        hv_FeatureLength = (hv_Features.TupleLength())/hv_NumRegions;
        hv_Step = hv_NumLevels*hv_FeatureLength;
      }
      hv_Indices = HTuple();
      {
      HTuple end_val20 = hv_NumRegions-1;
      HTuple step_val20 = 1;
      for (hv_J=0; hv_J.Continue(end_val20, step_val20); hv_J += step_val20)
      {
        hv_Start = (hv_J*hv_Step)+((hv_I-1)*hv_FeatureLength);
        hv_End = (hv_Start+hv_FeatureLength)-1;
        hv_Indices = hv_Indices.TupleConcat(HTuple::TupleGenSequence(hv_Start,hv_End,1));
      }
      }
      (*hv_Feature)[hv_Indices] = hv_Features;
    }
    }
  }
  return;
}

// Chapter: Classification / Misc
// Short Description: Calculate gray-value projections and their histograms. 
void calc_feature_gray_proj (HObject ho_Region, HObject ho_Image, HTuple hv_Mode, 
    HTuple hv_Size, HTuple *hv_Feature)
{

  // Local iconic variables
  HObject  ho_RegionTmp, ho_RegionMoved, ho_ImageTmp;

  // Local control variables
  HTuple  hv_NumRegions, hv_Index, hv_RowsTmp, hv_ColumnsTmp;
  HTuple  hv_HorProjectionFilledUp, hv_VertProjectionFilledUp;
  HTuple  hv_Row1, hv_Column1, hv_Row2, hv_Column2, hv_ScaleHeight;
  HTuple  hv_ScaleWidth, hv_HorProjection, hv_VertProjection;
  HTuple  hv_HorProjectionFilledUpFront, hv_VertProjectionFilledUpFront;
  HTuple  hv_Histo, hv_BinSize;

  //
  //Calculate gray-value projections and their histograms
  //
  CountObj(ho_Region, &hv_NumRegions);
  (*hv_Feature) = HTuple();
  //
  {
  HTuple end_val6 = hv_NumRegions;
  HTuple step_val6 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val6, step_val6); hv_Index += step_val6)
  {
    SelectObj(ho_Region, &ho_RegionTmp, hv_Index);
    //Test empty region
    GetRegionPoints(ho_RegionTmp, &hv_RowsTmp, &hv_ColumnsTmp);
    if (0 != ((hv_RowsTmp.TupleLength())==0))
    {
      hv_HorProjectionFilledUp = HTuple(hv_Size,-1.0);
      hv_VertProjectionFilledUp = HTuple(hv_Size,-1.0);
    }
    else
    {
      //Zoom image and region to Size x Size pixels
      SmallestRectangle1(ho_RegionTmp, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
      MoveRegion(ho_RegionTmp, &ho_RegionMoved, -hv_Row1, -hv_Column1);
      CropRectangle1(ho_Image, &ho_ImageTmp, hv_Row1, hv_Column1, hv_Row2, hv_Column2);
      hv_ScaleHeight = (hv_Size.TupleReal())/((hv_Row2-hv_Row1)+1);
      hv_ScaleWidth = (hv_Size.TupleReal())/((hv_Column2-hv_Column1)+1);
      ZoomImageFactor(ho_ImageTmp, &ho_ImageTmp, hv_ScaleWidth, hv_ScaleHeight, "constant");
      ZoomRegion(ho_RegionMoved, &ho_RegionTmp, hv_ScaleWidth, hv_ScaleHeight);
      //Calculate gray value projection
      GrayProjections(ho_RegionTmp, ho_ImageTmp, "simple", &hv_HorProjection, &hv_VertProjection);
      //Fill up projection in case the zoomed region is smaller than
      //Size x Size pixels due to interpolation effects
      SmallestRectangle1(ho_RegionTmp, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
      hv_HorProjectionFilledUpFront.Clear();
      hv_HorProjectionFilledUpFront.Append(HTuple(HTuple(0).TupleMax2(hv_Row1),-1.0));
      hv_HorProjectionFilledUpFront.Append(hv_HorProjection);
      hv_HorProjectionFilledUp.Clear();
      hv_HorProjectionFilledUp.Append(hv_HorProjectionFilledUpFront);
      hv_HorProjectionFilledUp.Append(HTuple(hv_Size-(hv_HorProjectionFilledUpFront.TupleLength()),-1.0));
      hv_VertProjectionFilledUpFront.Clear();
      hv_VertProjectionFilledUpFront.Append(HTuple(HTuple(0).TupleMax2(hv_Column1),-1.0));
      hv_VertProjectionFilledUpFront.Append(hv_VertProjection);
      hv_VertProjectionFilledUp.Clear();
      hv_VertProjectionFilledUp.Append(hv_VertProjectionFilledUpFront);
      hv_VertProjectionFilledUp.Append(HTuple(hv_Size-(hv_VertProjectionFilledUpFront.TupleLength()),-1.0));
    }
    if (0 != (hv_Mode==HTuple("hor")))
    {
      (*hv_Feature) = (*hv_Feature).TupleConcat(hv_HorProjectionFilledUp);
    }
    else if (0 != (hv_Mode==HTuple("vert")))
    {
      (*hv_Feature) = (*hv_Feature).TupleConcat(hv_VertProjectionFilledUp);
    }
    else if (0 != (hv_Mode==HTuple("hor_histo")))
    {
      TupleHistoRange(hv_HorProjectionFilledUp, 0, 255, hv_Size, &hv_Histo, &hv_BinSize);
      (*hv_Feature) = (*hv_Feature).TupleConcat(hv_Histo);
    }
    else if (0 != (hv_Mode==HTuple("vert_histo")))
    {
      TupleHistoRange(hv_VertProjectionFilledUp, 0, 255, hv_Size, &hv_Histo, &hv_BinSize);
      (*hv_Feature) = (*hv_Feature).TupleConcat(hv_Histo);
    }
  }
  }
  return;
}

// Chapter: Classification / Misc
// Short Description: Calculate one or more features of a given image and/or region. 
void calculate_features (HObject ho_Region, HObject ho_Image, HTuple hv_FeatureNames, 
    HTuple *hv_Features)
{

  //
  //Calculate features given in FeatureNames
  //for the input regions in Region
  //(if needed supported by the underlying
  //gray-value or color image Image).
  //
  get_features(ho_Region, ho_Image, hv_FeatureNames, "calculate", &(*hv_Features));
  return;
}

// Chapter: Classification / Misc
// Short Description: Calculate edge density histogram feature. 
void calc_feature_edge_density_histogram (HObject ho_Region, HObject ho_Image, HTuple hv_NumBins, 
    HTuple *hv_Feature)
{

  // Local iconic variables
  HObject  ho_Channel1, ho_EdgeAmplitude, ho_RegionSelected;

  // Local control variables
  HTuple  hv_ImageWidth, hv_ImageHeight, hv_NumRegions;
  HTuple  hv_J, hv_Area, hv_Row, hv_Column, hv_Histo, hv_BinSize;

  //
  //Calculate the edge density histogram, i.e.
  //the ratio of the edge amplitude histogram to the area of the region.
  //
  (*hv_Feature) = HTuple();
  GetImageSize(ho_Image, &hv_ImageWidth, &hv_ImageHeight);
  CountObj(ho_Region, &hv_NumRegions);
  if (0 != (HTuple(hv_ImageWidth>1).TupleAnd(hv_ImageHeight>1)))
  {
    AccessChannel(ho_Image, &ho_Channel1, 1);
    SobelAmp(ho_Channel1, &ho_EdgeAmplitude, "sum_abs", 3);
    {
    HTuple end_val10 = hv_NumRegions;
    HTuple step_val10 = 1;
    for (hv_J=1; hv_J.Continue(end_val10, step_val10); hv_J += step_val10)
    {
      SelectObj(ho_Region, &ho_RegionSelected, hv_J);
      AreaCenter(ho_RegionSelected, &hv_Area, &hv_Row, &hv_Column);
      if (0 != (hv_Area>0))
      {
        GrayHistoRange(ho_RegionSelected, ho_EdgeAmplitude, 0, 255, hv_NumBins, &hv_Histo, 
            &hv_BinSize);
        (*hv_Feature) = (*hv_Feature).TupleConcat((hv_Histo.TupleReal())/(hv_Histo.TupleSum()));
      }
      else
      {
        (*hv_Feature) = ((*hv_Feature).TupleConcat(1.0)).TupleConcat(HTuple(hv_NumBins-1,0.0));
      }
    }
    }
  }
  else
  {
    (*hv_Feature) = HTuple(hv_NumRegions*hv_NumBins,0.0);
  }
  return;
}

// Chapter: Classification / Misc
// Short Description: Calculate the gradient direction histogram. 
void calc_feature_grad_dir_histo (HObject ho_Region, HObject ho_Image, HTuple hv_NumBins, 
    HTuple *hv_Feature)
{

  // Local iconic variables
  HObject  ho_Channel1, ho_RegionSelected, ho_ImageReduced;
  HObject  ho_EdgeAmplitude, ho_EdgeDirection;

  // Local control variables
  HTuple  hv_NumRegions, hv_Index, hv_Histo, hv_BinSize;
  HTuple  hv_Sum;

  //
  //Calculate gradient direction histogram
  //
  AccessChannel(ho_Image, &ho_Channel1, 1);
  CountObj(ho_Region, &hv_NumRegions);
  (*hv_Feature) = HTuple();
  {
  HTuple end_val6 = hv_NumRegions;
  HTuple step_val6 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val6, step_val6); hv_Index += step_val6)
  {
    SelectObj(ho_Region, &ho_RegionSelected, hv_Index);
    ReduceDomain(ho_Channel1, ho_RegionSelected, &ho_ImageReduced);
    SobelDir(ho_ImageReduced, &ho_EdgeAmplitude, &ho_EdgeDirection, "sum_abs_binomial", 
        3);
    GrayHistoRange(ho_RegionSelected, ho_EdgeDirection, 0, 179, hv_NumBins, &hv_Histo, 
        &hv_BinSize);
    hv_Sum = hv_Histo.TupleSum();
    if (0 != (hv_Sum!=0))
    {
      (*hv_Feature) = (*hv_Feature).TupleConcat((hv_Histo.TupleReal())/hv_Sum);
    }
    else
    {
      (*hv_Feature) = (*hv_Feature).TupleConcat(hv_Histo);
    }
  }
  }
  return;
}

// Chapter: Classification / Misc
// Short Description: Generate a dummy image and region that are, e.g., used to determine the lengths of the feature vectors in get_feature_lengths. 
void gen_dummy_objects (HObject *ho_Region, HObject *ho_Image)
{

  //
  //Create dummy objects for the feature calculation
  //(may be used to determine the lengths of the
  //vectors etc.).
  //
  GenImageConst(&(*ho_Image), "byte", 3, 3);
  Compose3((*ho_Image), (*ho_Image), (*ho_Image), &(*ho_Image));
  GetDomain((*ho_Image), &(*ho_Region));
  return;
}

// Chapter: Classification / Misc
// Short Description: Calculate edge density. 
void calc_feature_edge_density (HObject ho_Region, HObject ho_Image, HTuple *hv_Feature)
{

  // Local iconic variables
  HObject  ho_RegionUnion, ho_ImageReduced, ho_EdgeAmplitude;

  // Local control variables
  HTuple  hv_Area, hv_Row, hv_Column, hv_Width;
  HTuple  hv_Height, hv_AreaGray, hv_ZeroIndex;

  //
  //Calculate the edge density, i.e.
  //the ratio of the edge amplitudes to the area of the region.
  //
  Union1(ho_Region, &ho_RegionUnion);
  ReduceDomain(ho_Image, ho_RegionUnion, &ho_ImageReduced);
  AreaCenter(ho_Region, &hv_Area, &hv_Row, &hv_Column);
  GetImageSize(ho_ImageReduced, &hv_Width, &hv_Height);
  if (0 != (HTuple(hv_Width>1).TupleAnd(hv_Height>1)))
  {
    SobelAmp(ho_ImageReduced, &ho_EdgeAmplitude, "sum_abs", 3);
    AreaCenterGray(ho_Region, ho_EdgeAmplitude, &hv_AreaGray, &hv_Row, &hv_Column);
    hv_ZeroIndex = hv_Area.TupleFind(0);
    if (0 != (hv_ZeroIndex!=-1))
    {
      hv_Area[hv_ZeroIndex] = 1;
      hv_AreaGray[hv_ZeroIndex] = 0;
    }
    (*hv_Feature) = hv_AreaGray/hv_Area;
  }
  else
  {
    (*hv_Feature) = HTuple(hv_Area.TupleLength(),0.0);
  }
  return;
}

// Chapter: Classification / Misc
// Short Description: Calculate gray-value projections of polar-transformed image regions. 
void calc_feature_polar_gray_proj (HObject ho_Region, HObject ho_Image, HTuple hv_Mode, 
    HTuple hv_Width, HTuple hv_Height, HTuple *hv_Features)
{

  // Local iconic variables
  HObject  ho_RegionSelected, ho_PolarTransImage;
  HObject  ho_EdgeAmplitude, ho_ImageAbs;

  // Local control variables
  HTuple  hv_NumRegions, hv_Index, hv_Row, hv_Column;
  HTuple  hv_Radius, hv_HorProjection, hv_VertProjection;

  //
  //Calculate gray-value projections of
  //polar-transformed image regions.
  //
  CountObj(ho_Region, &hv_NumRegions);
  (*hv_Features) = HTuple();
  {
  HTuple end_val6 = hv_NumRegions;
  HTuple step_val6 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val6, step_val6); hv_Index += step_val6)
  {
    SelectObj(ho_Region, &ho_RegionSelected, hv_Index);
    SmallestCircle(ho_RegionSelected, &hv_Row, &hv_Column, &hv_Radius);
    PolarTransImageExt(ho_Image, &ho_PolarTransImage, hv_Row, hv_Column, 0, HTuple(360).TupleRad(), 
        0, (hv_Radius.TupleConcat(1)).TupleMax(), hv_Width, hv_Height, "bilinear");
    //
    if (0 != (hv_Mode==HTuple("hor_gray")))
    {
      GrayProjections(ho_PolarTransImage, ho_PolarTransImage, "simple", &hv_HorProjection, 
          &hv_VertProjection);
      (*hv_Features) = (*hv_Features).TupleConcat(hv_HorProjection);
    }
    else if (0 != (hv_Mode==HTuple("vert_gray")))
    {
      GrayProjections(ho_PolarTransImage, ho_PolarTransImage, "simple", &hv_HorProjection, 
          &hv_VertProjection);
      (*hv_Features) = (*hv_Features).TupleConcat(hv_VertProjection);
    }
    else if (0 != (hv_Mode==HTuple("hor_sobel_amp")))
    {
      SobelAmp(ho_PolarTransImage, &ho_EdgeAmplitude, "sum_abs", 3);
      AbsImage(ho_EdgeAmplitude, &ho_ImageAbs);
      GrayProjections(ho_ImageAbs, ho_ImageAbs, "simple", &hv_HorProjection, &hv_VertProjection);
      (*hv_Features) = (*hv_Features).TupleConcat(hv_HorProjection);
    }
    else if (0 != (hv_Mode==HTuple("vert_sobel_amp")))
    {
      SobelAmp(ho_PolarTransImage, &ho_EdgeAmplitude, "sum_abs", 3);
      AbsImage(ho_EdgeAmplitude, &ho_ImageAbs);
      GrayProjections(ho_ImageAbs, ho_ImageAbs, "simple", &hv_HorProjection, &hv_VertProjection);
      (*hv_Features) = (*hv_Features).TupleConcat(hv_VertProjection);
    }
    else if (0 != (hv_Mode==HTuple("hor_sobel_x")))
    {
      SobelAmp(ho_PolarTransImage, &ho_EdgeAmplitude, "x_binomial", 3);
      AbsImage(ho_EdgeAmplitude, &ho_ImageAbs);
      GrayProjections(ho_ImageAbs, ho_ImageAbs, "simple", &hv_HorProjection, &hv_VertProjection);
      (*hv_Features) = (*hv_Features).TupleConcat(hv_HorProjection);
    }
    else if (0 != (hv_Mode==HTuple("vert_sobel_x")))
    {
      SobelAmp(ho_PolarTransImage, &ho_EdgeAmplitude, "x_binomial", 3);
      AbsImage(ho_EdgeAmplitude, &ho_ImageAbs);
      GrayProjections(ho_ImageAbs, ho_ImageAbs, "simple", &hv_HorProjection, &hv_VertProjection);
      (*hv_Features) = (*hv_Features).TupleConcat(hv_VertProjection);
    }
    else if (0 != (hv_Mode==HTuple("hor_sobel_y")))
    {
      SobelAmp(ho_PolarTransImage, &ho_EdgeAmplitude, "y_binomial", 3);
      AbsImage(ho_EdgeAmplitude, &ho_ImageAbs);
      GrayProjections(ho_ImageAbs, ho_ImageAbs, "simple", &hv_HorProjection, &hv_VertProjection);
      (*hv_Features) = (*hv_Features).TupleConcat(hv_HorProjection);
    }
    else if (0 != (hv_Mode==HTuple("vert_sobel_y")))
    {
      SobelAmp(ho_PolarTransImage, &ho_EdgeAmplitude, "y_binomial", 3);
      AbsImage(ho_EdgeAmplitude, &ho_ImageAbs);
      GrayProjections(ho_ImageAbs, ho_ImageAbs, "simple", &hv_HorProjection, &hv_VertProjection);
      (*hv_Features) = (*hv_Features).TupleConcat(hv_VertProjection);
    }
    else
    {
      throw HException(("Unknown Mode: "+hv_Mode)+" in calc_feature_polar_proj");
    }
  }
  }
  return;
}


