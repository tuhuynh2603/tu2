///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 13.0.2.2
///////////////////////////////////////////////////////////////////////////////




#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#endif



using namespace HalconCpp;

extern void gen_arrow_contour_xld (HObject *ho_Arrow, HTuple hv_Row1, HTuple hv_Column1, 
    HTuple hv_Row2, HTuple hv_Column2, HTuple hv_HeadLength, HTuple hv_HeadWidth);


// Chapter: Graphics / Output
// Short Description:  This procedure plots tuples representing functions or curves in a coordinate system. 
void plot_tuple (HTuple hv_WindowHandle, HTuple hv_XValues, HTuple hv_YValues, HTuple hv_XLabel, 
    HTuple hv_YLabel, HTuple hv_Color, HTuple hv_GenParamNames, HTuple hv_GenParamValues)
{

  // Local iconic variables
  HObject  ho_ContourXGrid, ho_ContourYGrid, ho_XArrow;
  HObject  ho_YArrow, ho_ContourXTick, ho_ContourYTick, ho_Contour;
  HObject  ho_Cross, ho_Filled;

  // Local control variables
  HTuple  hv_PreviousWindowHandle, hv_ClipRegion;
  HTuple  hv_Row, hv_Column, hv_Width, hv_Height, hv_PartRow1;
  HTuple  hv_PartColumn1, hv_PartRow2, hv_PartColumn2, hv_Red;
  HTuple  hv_Green, hv_Blue, hv_DrawMode, hv_OriginStyle;
  HTuple  hv_XAxisEndValue, hv_YAxisEndValue, hv_XAxisStartValue;
  HTuple  hv_YAxisStartValue, hv_XValuesAreStrings, hv_XTickValues;
  HTuple  hv_XTicks, hv_OriginX, hv_OriginY, hv_LeftBorder;
  HTuple  hv_RightBorder, hv_UpperBorder, hv_LowerBorder;
  HTuple  hv_AxesColor, hv_Style, hv_Clip, hv_YTicks, hv_XGrid;
  HTuple  hv_YGrid, hv_GridColor, hv_NumGenParamNames, hv_NumGenParamValues;
  HTuple  hv_SetOriginXToDefault, hv_SetOriginYToDefault;
  HTuple  hv_GenParamIndex, hv_XGridTicks, hv_XAxisWidthPx;
  HTuple  hv_XAxisWidth, hv_XScaleFactor, hv_YAxisHeightPx;
  HTuple  hv_YAxisHeight, hv_YScaleFactor, hv_YAxisOffsetPx;
  HTuple  hv_XAxisOffsetPx, hv_DotStyle, hv_XGridValues, hv_XGridStart;
  HTuple  hv_XPosition, hv_IndexGrid, hv_YGridValues, hv_YGridStart;
  HTuple  hv_YPosition, hv_Ascent, hv_Descent, hv_TextWidthXLabel;
  HTuple  hv_TextHeightXLabel, hv_XTickStart, hv_TypeTicks;
  HTuple  hv_IndexTicks, hv_YTickValues, hv_YTickStart, hv_Ascent1;
  HTuple  hv_Descent1, hv_TextWidthYTicks, hv_TextHeightYTicks;
  HTuple  hv_Num, hv_I, hv_YSelected, hv_Y1Selected, hv_X1Selected;

  //This procedure plots tuples representing functions
  //or curves in a coordinate system.
  //
  //Input parameters:
  //
  //XValues: X values of the function to be plotted
  //         If XValues is set to [], it is interally set to 0,1,2,...,|YValues|-1.
  //         If XValues is a tuple of strings, the values are taken as categories.
  //
  //YValues: Y values of the function(s) to be plotted
  //         If YValues is set to [], it is interally set to 0,1,2,...,|XValues|-1.
  //         The number of y values must be equal to the number of x values
  //         or an integral multiple. In the latter case,
  //         multiple functions are plotted, that share the same x values.
  //
  //XLabel: X axis label
  //
  //XLabel: Y axis label
  //
  //Color: Color of the plotted function
  //       If [] is given, the currently set display color is used.
  //       If 'none is given, the function is not plotted, but only
  //       the coordinate axes as specified.
  //       If more than one color is given, multiple functions
  //       can be displayed in different colors.
  //
  //GenParamNames: Generic parameters to control the presentation
  //               Possible Values:
  //   'axes_color': coordinate system color
  //                 Default: 'white'
  //                 If 'none' is given, no coordinate system is shown.
  //   'style': Graph style
  //            Possible values: 'line' (default), 'cross', 'filled'
  //   'clip': Clip graph to coordinate system area
  //           Possibile values: 'yes', 'no' (default)
  //   'ticks': Control display of ticks on the axes
  //            If 'min_max_origin' is given (default), ticks are shown
  //            at the minimum and maximum values of the axes and at the
  //            intercept point of x- and y-axis.
  //            If 'none' is given, no ticks are shown.
  //            If any number != 0 is given, it is interpreted as distance
  //            between the ticks.
  //   'ticks_x': Control display of ticks on x-axis only
  //   'ticks_y': Control display of ticks on y-axis only
  //   'grid': Control display of grid lines within the coordinate system
  //           If 'min_max_origin' is given (default), grid lines are shown
  //           at the minimum and maximum values of the axes.
  //           If 'none' is given, no grid lines are shown.
  //           If any number != 0 is given, it is interpreted as distance
  //           between the grid lines.
  //   'grid_x': Control display of grid lines for the x-axis only
  //   'grid_y': Control display of grid lines for the y-axis only
  //   'grid_color': Color of the grid (default: 'dim gray')
  //   'margin': The distance in pixels of the coordinate system area
  //             to all four window borders.
  //   'margin_left': The distance in pixels of the coordinate system area
  //                  to the left window border.
  //   'margin_right': The distance in pixels of the coordinate system area
  //                   to the right window border.
  //   'margin_top': The distance in pixels of the coordinate system area
  //                 to the upper window border.
  //   'margin_bottom': The distance in pixels of the coordinate system area
  //                    to the lower window border.
  //   'start_x': Lowest x value of the x axis
  //              Default: min(XValues)
  //   'end_x': Highest x value of the x axis
  //            Default: max(XValues)
  //   'start_y': Lowest y value of the x axis
  //              Default: min(YValues)
  //   'end_y': Highest y value of the x axis
  //            Default: max(YValues)
  //   'origin_x': X coordinate of the intercept point of x- and y-axis.
  //               Default: same as start_x
  //   'origin_y': Y coordinate of the intercept point of x- and y-axis.
  //               Default: same as start_y
  //
  //GenParamValues: Values of the generic parameters of GenericParamNames
  //
  //
  //Store current display settings
  if (HDevWindowStack::IsOpen())
    hv_PreviousWindowHandle = HDevWindowStack::GetActive();
  HDevWindowStack::SetActive(hv_WindowHandle);
  GetSystem("clip_region", &hv_ClipRegion);
  GetWindowExtents(hv_WindowHandle, &hv_Row, &hv_Column, &hv_Width, &hv_Height);
  GetPart(hv_WindowHandle, &hv_PartRow1, &hv_PartColumn1, &hv_PartRow2, &hv_PartColumn2);
  GetRgb(hv_WindowHandle, &hv_Red, &hv_Green, &hv_Blue);
  GetDraw(hv_WindowHandle, &hv_DrawMode);
  GetLineStyle(hv_WindowHandle, &hv_OriginStyle);
  //
  //Set display parameters
  SetLineStyle(hv_WindowHandle, HTuple());
  SetSystem("clip_region", "false");
  if (HDevWindowStack::IsOpen())
    SetPart(HDevWindowStack::GetActive(),0, 0, hv_Height-1, hv_Width-1);
  //
  //Check input coordinates
  //
  if (0 != (HTuple(hv_XValues==HTuple()).TupleAnd(hv_YValues==HTuple())))
  {
    //Neither XValues nor YValues are given:
    //Set axes to interval [0,1]
    hv_XAxisEndValue = 1;
    hv_YAxisEndValue = 1;
    hv_XAxisStartValue = 0;
    hv_YAxisStartValue = 0;
    hv_XValuesAreStrings = 0;
  }
  else
  {
    if (0 != (hv_XValues==HTuple()))
    {
      //XValues are omitted:
      //Set equidistant XValues
      hv_XValues = HTuple::TupleGenSequence(0,(hv_YValues.TupleLength())-1,1);
      hv_XValuesAreStrings = 0;
    }
    else if (0 != (hv_YValues==HTuple()))
    {
      //YValues are omitted:
      //Set equidistant YValues
      hv_YValues = HTuple::TupleGenSequence(0,(hv_XValues.TupleLength())-1,1);
    }
    if (0 != (((hv_YValues.TupleLength())%(hv_XValues.TupleLength()))!=0))
    {
      //Number of YValues does not match number of XValues
      throw HException("Number of YValues is no multiple of the number of XValues!");
      return;
    }
    hv_XValuesAreStrings = hv_XValues.TupleIsStringElem();
    hv_XValuesAreStrings = (hv_XValuesAreStrings.TupleSum())==(hv_XValuesAreStrings.TupleLength());
    if (0 != hv_XValuesAreStrings)
    {
      //XValues are given as strings:
      //Show XValues as ticks
      hv_XTickValues = hv_XValues;
      hv_XTicks = 1;
      //Set x-axis dimensions
      hv_XValues = HTuple::TupleGenSequence(1,hv_XValues.TupleLength(),1);
    }
    //Set default x-axis dimensions
    if (0 != ((hv_XValues.TupleLength())>1))
    {
      hv_XAxisStartValue = hv_XValues.TupleMin();
      hv_XAxisEndValue = hv_XValues.TupleMax();
    }
    else
    {
      hv_XAxisEndValue = HTuple(hv_XValues[0])+0.5;
      hv_XAxisStartValue = HTuple(hv_XValues[0])-0.5;
    }
  }
  //Set default y-axis dimensions
  if (0 != ((hv_YValues.TupleLength())>1))
  {
    hv_YAxisStartValue = hv_YValues.TupleMin();
    hv_YAxisEndValue = hv_YValues.TupleMax();
  }
  else if (0 != ((hv_YValues.TupleLength())==1))
  {
    hv_YAxisStartValue = HTuple(hv_YValues[0])-0.5;
    hv_YAxisEndValue = HTuple(hv_YValues[0])+0.5;
  }
  else
  {
    hv_YAxisStartValue = 0;
    hv_YAxisEndValue = 1;
  }
  //Set default interception point of x- and y- axis
  hv_OriginX = hv_XAxisStartValue;
  hv_OriginY = hv_YAxisStartValue;
  //
  //Set more defaults
  hv_LeftBorder = hv_Width*0.1;
  hv_RightBorder = hv_Width*0.1;
  hv_UpperBorder = hv_Height*0.1;
  hv_LowerBorder = hv_Height*0.1;
  hv_AxesColor = "white";
  hv_Style = "line";
  hv_Clip = "no";
  hv_XTicks = "min_max_origin";
  hv_YTicks = "min_max_origin";
  hv_XGrid = "none";
  hv_YGrid = "none";
  hv_GridColor = "dim gray";
  //
  //Parse generic parameters
  //
  hv_NumGenParamNames = hv_GenParamNames.TupleLength();
  hv_NumGenParamValues = hv_GenParamValues.TupleLength();
  if (0 != (hv_NumGenParamNames!=hv_NumGenParamValues))
  {
    throw HException("Number of generic parameter names does not match generic parameter values!");
    return;
  }
  //
  hv_SetOriginXToDefault = 1;
  hv_SetOriginYToDefault = 1;
  {
  HTuple end_val179 = (hv_GenParamNames.TupleLength())-1;
  HTuple step_val179 = 1;
  for (hv_GenParamIndex=0; hv_GenParamIndex.Continue(end_val179, step_val179); hv_GenParamIndex += step_val179)
  {
    //
    //Set 'axes_color'
    if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("axes_color")))
    {
      hv_AxesColor = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'style'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("style")))
    {
      hv_Style = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'clip'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("clip")))
    {
      hv_Clip = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      if (0 != (HTuple(hv_Clip!=HTuple("yes")).TupleAnd(hv_Clip!=HTuple("no"))))
      {
        throw HException(("Unsupported clipping option: '"+hv_Clip)+"'");
      }
      //
      //Set 'ticks'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("ticks")))
    {
      hv_XTicks = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      hv_YTicks = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'ticks_x'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("ticks_x")))
    {
      hv_XTicks = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'ticks_y'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("ticks_y")))
    {
      hv_YTicks = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'grid'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("grid")))
    {
      hv_XGrid = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      hv_YGrid = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      hv_XGridTicks = hv_XTicks;
      //
      //Set 'grid_x'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("grid_x")))
    {
      hv_XGrid = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'grid_y'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("grid_y")))
    {
      hv_YGrid = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'grid_color'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("grid_color")))
    {
      hv_GridColor = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'start_x'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("start_x")))
    {
      hv_XAxisStartValue = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'end_x'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("end_x")))
    {
      hv_XAxisEndValue = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'start_y'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("start_y")))
    {
      hv_YAxisStartValue = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'end_y'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("end_y")))
    {
      hv_YAxisEndValue = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'origin_x'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("origin_x")))
    {
      hv_OriginX = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      hv_SetOriginXToDefault = 0;
      //
      //Set 'origin_y'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("origin_y")))
    {
      hv_OriginY = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      hv_SetOriginYToDefault = 0;
      //
      //Set 'margin'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("margin")))
    {
      hv_LeftBorder = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      hv_RightBorder = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      hv_UpperBorder = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      hv_LowerBorder = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'margin_left'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("margin_left")))
    {
      hv_LeftBorder = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'margin_right'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("margin_right")))
    {
      hv_RightBorder = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'margin_top'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("margin_top")))
    {
      hv_UpperBorder = HTuple(hv_GenParamValues[hv_GenParamIndex]);
      //
      //Set 'margin_bottom'
    }
    else if (0 != (HTuple(hv_GenParamNames[hv_GenParamIndex])==HTuple("margin_bottom")))
    {
      hv_LowerBorder = HTuple(hv_GenParamValues[hv_GenParamIndex]);
    }
    else
    {
      throw HException(("Unknown generic parameter: '"+HTuple(hv_GenParamNames[hv_GenParamIndex]))+"'");
    }
  }
  }
  //
  //
  //Check consistency of start and end values
  //of the axes.
  if (0 != (hv_XAxisStartValue>hv_XAxisEndValue))
  {
    throw HException("Value for 'start_x' is greater than value for 'end_x'");
  }
  if (0 != (hv_YAxisStartValue>hv_YAxisEndValue))
  {
    throw HException("Value for 'start_y' is greater than value for 'end_y'");
  }
  //
  //Set default origin to lower left corner
  if (0 != hv_SetOriginXToDefault)
  {
    hv_OriginX = hv_XAxisStartValue;
  }
  if (0 != hv_SetOriginYToDefault)
  {
    hv_OriginY = hv_YAxisStartValue;
  }
  //
  //
  //Calculate basic pixel coordinates and scale factors
  //
  hv_XAxisWidthPx = (hv_Width-hv_LeftBorder)-hv_RightBorder;
  hv_XAxisWidth = hv_XAxisEndValue-hv_XAxisStartValue;
  if (0 != (hv_XAxisWidth==0))
  {
    hv_XAxisStartValue = hv_XAxisStartValue-0.5;
    hv_XAxisEndValue += 0.5;
    hv_XAxisWidth = 1;
  }
  hv_XScaleFactor = hv_XAxisWidthPx/(hv_XAxisWidth.TupleReal());
  hv_YAxisHeightPx = (hv_Height-hv_LowerBorder)-hv_UpperBorder;
  hv_YAxisHeight = hv_YAxisEndValue-hv_YAxisStartValue;
  if (0 != (hv_YAxisHeight==0))
  {
    hv_YAxisStartValue = hv_YAxisStartValue-0.5;
    hv_YAxisEndValue += 0.5;
    hv_YAxisHeight = 1;
  }
  hv_YScaleFactor = hv_YAxisHeightPx/(hv_YAxisHeight.TupleReal());
  hv_YAxisOffsetPx = (hv_OriginX-hv_XAxisStartValue)*hv_XScaleFactor;
  hv_XAxisOffsetPx = (hv_OriginY-hv_YAxisStartValue)*hv_YScaleFactor;
  //
  //Display grid lines
  //
  if (0 != (hv_GridColor!=HTuple("none")))
  {
    hv_DotStyle.Clear();
    hv_DotStyle[0] = 5;
    hv_DotStyle[1] = 7;
    SetLineStyle(hv_WindowHandle, hv_DotStyle);
    if (HDevWindowStack::IsOpen())
      SetColor(HDevWindowStack::GetActive(),hv_GridColor);
    //
    //Display x grid lines
    if (0 != (hv_XGrid!=HTuple("none")))
    {
      if (0 != (hv_XGrid==HTuple("min_max_origin")))
      {
        //Calculate 'min_max_origin' grid line coordinates
        if (0 != (hv_OriginX==hv_XAxisStartValue))
        {
          hv_XGridValues.Clear();
          hv_XGridValues.Append(hv_XAxisStartValue);
          hv_XGridValues.Append(hv_XAxisEndValue);
        }
        else
        {
          hv_XGridValues.Clear();
          hv_XGridValues.Append(hv_XAxisStartValue);
          hv_XGridValues.Append(hv_OriginX);
          hv_XGridValues.Append(hv_XAxisEndValue);
        }
      }
      else
      {
        //Calculate equidistant grid line coordinates
        hv_XGridStart = ((hv_XAxisStartValue/hv_XGrid).TupleCeil())*hv_XGrid;
        hv_XGridValues = HTuple::TupleGenSequence(hv_XGridStart,hv_XAxisEndValue,hv_XGrid);
      }
      hv_XPosition = (hv_XGridValues-hv_XAxisStartValue)*hv_XScaleFactor;
      //Generate and display grid lines
      {
      HTuple end_val343 = (hv_XGridValues.TupleLength())-1;
      HTuple step_val343 = 1;
      for (hv_IndexGrid=0; hv_IndexGrid.Continue(end_val343, step_val343); hv_IndexGrid += step_val343)
      {
        GenContourPolygonXld(&ho_ContourXGrid, (hv_Height-hv_LowerBorder).TupleConcat(hv_UpperBorder), 
            (hv_LeftBorder+HTuple(hv_XPosition[hv_IndexGrid])).TupleConcat(hv_LeftBorder+HTuple(hv_XPosition[hv_IndexGrid])));
        if (HDevWindowStack::IsOpen())
          DispObj(ho_ContourXGrid, HDevWindowStack::GetActive());
      }
      }
    }
    //
    //Display y grid lines
    if (0 != (hv_YGrid!=HTuple("none")))
    {
      if (0 != (hv_YGrid==HTuple("min_max_origin")))
      {
        //Calculate 'min_max_origin' grid line coordinates
        if (0 != (hv_OriginY==hv_YAxisStartValue))
        {
          hv_YGridValues.Clear();
          hv_YGridValues.Append(hv_YAxisStartValue);
          hv_YGridValues.Append(hv_YAxisEndValue);
        }
        else
        {
          hv_YGridValues.Clear();
          hv_YGridValues.Append(hv_YAxisStartValue);
          hv_YGridValues.Append(hv_OriginY);
          hv_YGridValues.Append(hv_YAxisEndValue);
        }
      }
      else
      {
        //Calculate equidistant grid line coordinates
        hv_YGridStart = ((hv_YAxisStartValue/hv_YGrid).TupleCeil())*hv_YGrid;
        hv_YGridValues = HTuple::TupleGenSequence(hv_YGridStart,hv_YAxisEndValue,hv_YGrid);
      }
      hv_YPosition = (hv_YGridValues-hv_YAxisStartValue)*hv_YScaleFactor;
      //Generate and display grid lines
      {
      HTuple end_val365 = (hv_YGridValues.TupleLength())-1;
      HTuple step_val365 = 1;
      for (hv_IndexGrid=0; hv_IndexGrid.Continue(end_val365, step_val365); hv_IndexGrid += step_val365)
      {
        GenContourPolygonXld(&ho_ContourYGrid, ((hv_Height-hv_LowerBorder)-HTuple(hv_YPosition[hv_IndexGrid])).TupleConcat((hv_Height-hv_LowerBorder)-HTuple(hv_YPosition[hv_IndexGrid])), 
            hv_LeftBorder.TupleConcat(hv_Width-hv_RightBorder));
        if (HDevWindowStack::IsOpen())
          DispObj(ho_ContourYGrid, HDevWindowStack::GetActive());
      }
      }
    }
  }
  SetLineStyle(hv_WindowHandle, HTuple());
  //
  //
  //Display the coordinate sytem axes
  if (0 != (hv_AxesColor!=HTuple("none")))
  {
    //Display axes
    if (HDevWindowStack::IsOpen())
      SetColor(HDevWindowStack::GetActive(),hv_AxesColor);
    gen_arrow_contour_xld(&ho_XArrow, (hv_Height-hv_LowerBorder)-hv_XAxisOffsetPx, 
        hv_LeftBorder, (hv_Height-hv_LowerBorder)-hv_XAxisOffsetPx, hv_Width-hv_RightBorder, 
        0, 0);
    if (HDevWindowStack::IsOpen())
      DispObj(ho_XArrow, HDevWindowStack::GetActive());
    gen_arrow_contour_xld(&ho_YArrow, hv_Height-hv_LowerBorder, hv_LeftBorder+hv_YAxisOffsetPx, 
        hv_UpperBorder, hv_LeftBorder+hv_YAxisOffsetPx, 0, 0);
    if (HDevWindowStack::IsOpen())
      DispObj(ho_YArrow, HDevWindowStack::GetActive());
    //Display labels
    GetStringExtents(hv_WindowHandle, hv_XLabel, &hv_Ascent, &hv_Descent, &hv_TextWidthXLabel, 
        &hv_TextHeightXLabel);
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),hv_XLabel, "image", ((hv_Height-hv_LowerBorder)-hv_TextHeightXLabel)-hv_XAxisOffsetPx, 
          ((hv_Width-hv_RightBorder)-hv_TextWidthXLabel)-3, hv_AxesColor, "box", 
          "false");
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive()," "+hv_YLabel, "image", hv_UpperBorder, 
          (hv_LeftBorder+3)+hv_YAxisOffsetPx, hv_AxesColor, "box", "false");
  }
  //
  //Display ticks
  //
  if (0 != (hv_AxesColor!=HTuple("none")))
  {
    if (HDevWindowStack::IsOpen())
      SetColor(HDevWindowStack::GetActive(),hv_AxesColor);
    if (0 != (hv_XTicks!=HTuple("none")))
    {
      //
      //Display x ticks
      if (0 != hv_XValuesAreStrings)
      {
        //Display string XValues as categories
        hv_XTicks = (hv_XValues.TupleLength())/(hv_XTickValues.TupleLength());
        hv_XPosition = (hv_XValues-hv_XAxisStartValue)*hv_XScaleFactor;
      }
      else
      {
        //Display tick values
        if (0 != (hv_XTicks==HTuple("min_max_origin")))
        {
          //Calculate 'min_max_origin' tick coordinates
          if (0 != (hv_OriginX==hv_XAxisStartValue))
          {
            hv_XTickValues.Clear();
            hv_XTickValues.Append(hv_XAxisStartValue);
            hv_XTickValues.Append(hv_XAxisEndValue);
          }
          else
          {
            hv_XTickValues.Clear();
            hv_XTickValues.Append(hv_XAxisStartValue);
            hv_XTickValues.Append(hv_OriginX);
            hv_XTickValues.Append(hv_XAxisEndValue);
          }
        }
        else
        {
          //Calculate equidistant tick coordinates
          hv_XTickStart = ((hv_XAxisStartValue/hv_XTicks).TupleCeil())*hv_XTicks;
          hv_XTickValues = HTuple::TupleGenSequence(hv_XTickStart,hv_XAxisEndValue,hv_XTicks);
        }
        hv_XPosition = (hv_XTickValues-hv_XAxisStartValue)*hv_XScaleFactor;
        hv_TypeTicks = hv_XTicks.TupleType();
        if (0 != (hv_TypeTicks==4))
        {
          //String ('min_max_origin')
          //Format depends on actual values
          hv_TypeTicks = hv_XTickValues.TupleType();
        }
        if (0 != (hv_TypeTicks==1))
        {
          //Round to integer
          hv_XTickValues = hv_XTickValues.TupleInt();
        }
        else
        {
          //Use floating point numbers
          hv_XTickValues = hv_XTickValues.TupleString(".2f");
        }
      }
      //Generate and display ticks
      {
      HTuple end_val429 = (hv_XTickValues.TupleLength())-1;
      HTuple step_val429 = 1;
      for (hv_IndexTicks=0; hv_IndexTicks.Continue(end_val429, step_val429); hv_IndexTicks += step_val429)
      {
        GenContourPolygonXld(&ho_ContourXTick, ((hv_Height-hv_LowerBorder)-hv_XAxisOffsetPx).TupleConcat(((hv_Height-hv_LowerBorder)-hv_XAxisOffsetPx)-5), 
            (hv_LeftBorder+HTuple(hv_XPosition[hv_IndexTicks])).TupleConcat(hv_LeftBorder+HTuple(hv_XPosition[hv_IndexTicks])));
        if (HDevWindowStack::IsOpen())
          DispObj(ho_ContourXTick, HDevWindowStack::GetActive());
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),HTuple(hv_XTickValues[hv_IndexTicks]), 
              "image", ((hv_Height-hv_LowerBorder)+2)-hv_XAxisOffsetPx, hv_LeftBorder+HTuple(hv_XPosition[hv_IndexTicks]), 
              hv_AxesColor, "box", "false");
      }
      }
    }
    //
    if (0 != (hv_YTicks!=HTuple("none")))
    {
      //
      //Display y ticks
      if (0 != (hv_YTicks==HTuple("min_max_origin")))
      {
        //Calculate 'min_max_origin' tick coordinates
        if (0 != (hv_OriginY==hv_YAxisStartValue))
        {
          hv_YTickValues.Clear();
          hv_YTickValues.Append(hv_YAxisStartValue);
          hv_YTickValues.Append(hv_YAxisEndValue);
        }
        else
        {
          hv_YTickValues.Clear();
          hv_YTickValues.Append(hv_YAxisStartValue);
          hv_YTickValues.Append(hv_OriginY);
          hv_YTickValues.Append(hv_YAxisEndValue);
        }
      }
      else
      {
        //Calculate equidistant tick coordinates
        hv_YTickStart = ((hv_YAxisStartValue/hv_YTicks).TupleCeil())*hv_YTicks;
        hv_YTickValues = HTuple::TupleGenSequence(hv_YTickStart,hv_YAxisEndValue,hv_YTicks);
      }
      hv_YPosition = (hv_YTickValues-hv_YAxisStartValue)*hv_YScaleFactor;
      hv_TypeTicks = hv_YTicks.TupleType();
      if (0 != (hv_TypeTicks==4))
      {
        //String ('min_max_origin')
        //Format depends on actual values
        hv_TypeTicks = hv_YTickValues.TupleType();
      }
      if (0 != (hv_TypeTicks==1))
      {
        //Round to integer
        hv_YTickValues = hv_YTickValues.TupleInt();
      }
      else
      {
        //Use floating point numbers
        hv_YTickValues = hv_YTickValues.TupleString(".2f");
      }
      //Generate and display ticks
      {
      HTuple end_val466 = (hv_YTickValues.TupleLength())-1;
      HTuple step_val466 = 1;
      for (hv_IndexTicks=0; hv_IndexTicks.Continue(end_val466, step_val466); hv_IndexTicks += step_val466)
      {
        GenContourPolygonXld(&ho_ContourYTick, ((hv_Height-hv_LowerBorder)-HTuple(hv_YPosition[hv_IndexTicks])).TupleConcat((hv_Height-hv_LowerBorder)-HTuple(hv_YPosition[hv_IndexTicks])), 
            (hv_LeftBorder+hv_YAxisOffsetPx).TupleConcat((hv_LeftBorder+hv_YAxisOffsetPx)+5));
        if (HDevWindowStack::IsOpen())
          DispObj(ho_ContourYTick, HDevWindowStack::GetActive());
        GetStringExtents(hv_WindowHandle, HTuple(hv_YTickValues[hv_IndexTicks]), 
            &hv_Ascent1, &hv_Descent1, &hv_TextWidthYTicks, &hv_TextHeightYTicks);
        if (HDevWindowStack::IsOpen())
          DispText(HDevWindowStack::GetActive(),HTuple(hv_YTickValues[hv_IndexTicks]), 
              "image", (((hv_Height-hv_LowerBorder)-hv_TextHeightYTicks)+3)-HTuple(hv_YPosition[hv_IndexTicks]), 
              ((hv_LeftBorder-hv_TextWidthYTicks)-2)+hv_YAxisOffsetPx, hv_AxesColor, 
              "box", "false");
      }
      }
    }
  }
  //
  //Display function plot
  //
  if (0 != (hv_Color!=HTuple("none")))
  {
    if (0 != (HTuple(hv_XValues!=HTuple()).TupleAnd(hv_YValues!=HTuple())))
    {
      hv_Num = (hv_YValues.TupleLength())/(hv_XValues.TupleLength());
      //
      //Iterate over all functions to be displayed
      {
      HTuple end_val482 = hv_Num-1;
      HTuple step_val482 = 1;
      for (hv_I=0; hv_I.Continue(end_val482, step_val482); hv_I += step_val482)
      {
        //Select y values for current function
        hv_YSelected = hv_YValues.TupleSelectRange(hv_I*(hv_XValues.TupleLength()),((hv_I+1)*(hv_XValues.TupleLength()))-1);
        //Set color
        if (0 != (hv_Color==HTuple()))
        {
          SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
        }
        else
        {
          if (HDevWindowStack::IsOpen())
            SetColor(HDevWindowStack::GetActive(),HTuple(hv_Color[hv_I%(hv_Color.TupleLength())]));
        }
        //
        //Display in different styles
        //
        if (0 != (HTuple(hv_Style==HTuple("line")).TupleOr(hv_Style==HTuple())))
        {
          //Line
          GenContourPolygonXld(&ho_Contour, ((hv_Height-hv_LowerBorder)-(hv_YSelected*hv_YScaleFactor))+(hv_YAxisStartValue*hv_YScaleFactor), 
              ((hv_XValues*hv_XScaleFactor)+hv_LeftBorder)-(hv_XAxisStartValue*hv_XScaleFactor));
          //Clip, if necessary
          if (0 != (hv_Clip==HTuple("yes")))
          {
            ClipContoursXld(ho_Contour, &ho_Contour, hv_UpperBorder, hv_LeftBorder, 
                hv_Height-hv_LowerBorder, hv_Width-hv_RightBorder);
          }
          if (HDevWindowStack::IsOpen())
            DispObj(ho_Contour, HDevWindowStack::GetActive());
        }
        else if (0 != (hv_Style==HTuple("cross")))
        {
          //Cross
          GenCrossContourXld(&ho_Cross, ((hv_Height-hv_LowerBorder)-(hv_YSelected*hv_YScaleFactor))+(hv_YAxisStartValue*hv_YScaleFactor), 
              ((hv_XValues*hv_XScaleFactor)+hv_LeftBorder)-(hv_XAxisStartValue*hv_XScaleFactor), 
              6, 0.785398);
          //Clip, if necessary
          if (0 != (hv_Clip==HTuple("yes")))
          {
            ClipContoursXld(ho_Cross, &ho_Cross, hv_UpperBorder, hv_LeftBorder, hv_Height-hv_LowerBorder, 
                hv_Width-hv_RightBorder);
          }
          if (HDevWindowStack::IsOpen())
            DispObj(ho_Cross, HDevWindowStack::GetActive());
        }
        else if (0 != (hv_Style==HTuple("filled")))
        {
          //Filled
          hv_Y1Selected.Clear();
          hv_Y1Selected.Append(0+hv_OriginY);
          hv_Y1Selected.Append(hv_YSelected);
          hv_Y1Selected.Append(0+hv_OriginY);
          hv_X1Selected.Clear();
          hv_X1Selected.Append(hv_XValues.TupleMin());
          hv_X1Selected.Append(hv_XValues);
          hv_X1Selected.Append(hv_XValues.TupleMax());
          if (HDevWindowStack::IsOpen())
            SetDraw(HDevWindowStack::GetActive(),"fill");
          GenRegionPolygonFilled(&ho_Filled, ((hv_Height-hv_LowerBorder)-(hv_Y1Selected*hv_YScaleFactor))+(hv_YAxisStartValue*hv_YScaleFactor), 
              ((hv_X1Selected*hv_XScaleFactor)+hv_LeftBorder)-(hv_XAxisStartValue*hv_XScaleFactor));
          //Clip, if necessary
          if (0 != (hv_Clip==HTuple("yes")))
          {
            ClipRegion(ho_Filled, &ho_Filled, hv_UpperBorder, hv_LeftBorder, hv_Height-hv_LowerBorder, 
                hv_Width-hv_RightBorder);
          }
          if (HDevWindowStack::IsOpen())
            DispObj(ho_Filled, HDevWindowStack::GetActive());
        }
        else
        {
          throw HException("Unsupported style: "+hv_Style);
        }
      }
      }
    }
  }
  //
  //
  //Reset original display settings
  if (HDevWindowStack::IsOpen())
    SetPart(HDevWindowStack::GetActive(),hv_PartRow1, hv_PartColumn1, hv_PartRow2, 
        hv_PartColumn2);
  HDevWindowStack::SetActive(hv_PreviousWindowHandle);
  SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
  if (HDevWindowStack::IsOpen())
    SetDraw(HDevWindowStack::GetActive(),hv_DrawMode);
  SetLineStyle(hv_WindowHandle, hv_OriginStyle);
  SetSystem("clip_region", hv_ClipRegion);
  return;
}
