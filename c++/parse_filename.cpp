///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 13.0.2.2
///////////////////////////////////////////////////////////////////////////////




#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#endif



using namespace HalconCpp;


// Chapter: File / Misc
// Short Description: Parse a filename into directory, base filename, and extension 
void parse_filename (HTuple hv_FileName, HTuple *hv_BaseName, HTuple *hv_Extension, 
    HTuple *hv_Directory)
{

  // Local control variables
  HTuple  hv_DirectoryTmp, hv_Substring;

  //This procedure gets a filename (with full path) as input
  //and returns the directory path, the base filename and the extension
  //in three different strings.
  //
  //In the output path the path separators will be replaced
  //by '/' in all cases.
  //
  //The procedure shows the possibilities of regular expressions in HALCON.
  //
  //Input parameters:
  //FileName: The input filename
  //
  //Output parameters:
  //BaseName: The filename without directory description and file extension
  //Extension: The file extension
  //Directory: The directory path
  //
  //Example:
  //basename('C:/images/part_01.png',...) returns
  //BaseName = 'part_01'
  //Extension = 'png'
  //Directory = 'C:\\images\\' (on Windows systems)
  //
  //Explanation of the regular expressions:
  //
  //'([^\\\\/]*?)(?:\\.[^.]*)?$':
  //To start at the end, the '$' matches the end of the string,
  //so it is best to read the expression from right to left.
  //The part in brackets (?:\\.[^.}*) denotes a non-capturing group.
  //That means, that this part is matched, but not captured
  //in contrast to the first bracketed group ([^\\\\/], see below.)
  //\\.[^.]* matches a dot '.' followed by as many non-dots as possible.
  //So (?:\\.[^.]*)? matches the file extension, if any.
  //The '?' at the end assures, that even if no extension exists,
  //a correct match is returned.
  //The first part in brackets ([^\\\\/]*?) is a capture group,
  //which means, that if a match is found, only the part in
  //brackets is returned as a result.
  //Because both HDevelop strings and regular expressions need a '\\'
  //to describe a backslash, inside regular expressions within HDevelop
  //a backslash has to be written as '\\\\'.
  //[^\\\\/] matches any character but a slash or backslash ('\\' in HDevelop)
  //[^\\\\/]*? matches a string od 0..n characters (except '/' or '\\')
  //where the '?' after the '*' switches the greediness off,
  //that means, that the shortest possible match is returned.
  //This option is necessary to cut off the extension
  //but only if (?:\\.[^.]*)? is able to match one.
  //To summarize, the regular expression matches that part of
  //the input string, that follows after the last '/' or '\\' and
  //cuts off the extension (if any) after the last '.'.
  //
  //'\\.([^.]*)$':
  //This matches everything after the last '.' of the input string.
  //Because ([^.]) is a capturing group,
  //only the part after the dot is returned.
  //
  //'.*[\\\\/]':
  //This matches the longest substring with a '/' or a '\\' at the end.
  //
  TupleRegexpMatch(hv_FileName, ".*[\\\\/]", &hv_DirectoryTmp);
  TupleSubstr(hv_FileName, hv_DirectoryTmp.TupleStrlen(), (hv_FileName.TupleStrlen())-1, 
      &hv_Substring);
  TupleRegexpMatch(hv_Substring, "([^\\\\/]*?)(?:\\.[^.]*)?$", &(*hv_BaseName));
  TupleRegexpMatch(hv_Substring, "\\.([^.]*)$", &(*hv_Extension));
  //
  //
  //Finally all found backslashes ('\\') are converted
  //to a slash to get consistent paths
  TupleRegexpReplace(hv_DirectoryTmp, (HTuple("\\\\").Append("replace_all")), "/", 
      &(*hv_Directory));
  return;
}
