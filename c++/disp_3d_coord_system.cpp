///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 13.0.2.2
///////////////////////////////////////////////////////////////////////////////




#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#endif



using namespace HalconCpp;

extern void gen_arrow_contour_xld (HObject *ho_Arrow, HTuple hv_Row1, HTuple hv_Column1, 
    HTuple hv_Row2, HTuple hv_Column2, HTuple hv_HeadLength, HTuple hv_HeadWidth);

extern void get_cam_par_data (HTuple hv_CameraParam, HTuple hv_ParamName, HTuple *hv_ParamValue);


// Chapter: Graphics / Output
// Short Description: Display the axes of a 3d coordinate system 
void disp_3d_coord_system (HTuple hv_WindowHandle, HTuple hv_CamParam, HTuple hv_Pose, 
    HTuple hv_CoordAxesLength)
{

  // Local iconic variables
  HObject  ho_Arrows;

  // Local control variables
  HTuple  hv_CameraType, hv_IsTelecentric, hv_TransWorld2Cam;
  HTuple  hv_OrigCamX, hv_OrigCamY, hv_OrigCamZ, hv_Row0;
  HTuple  hv_Column0, hv_X, hv_Y, hv_Z, hv_RowAxX, hv_ColumnAxX;
  HTuple  hv_RowAxY, hv_ColumnAxY, hv_RowAxZ, hv_ColumnAxZ;
  HTuple  hv_Distance, hv_HeadLength, hv_Red, hv_Green, hv_Blue;

  //This procedure displays a 3D coordinate system.
  //It needs the procedure gen_arrow_contour_xld.
  //
  //Input parameters:
  //WindowHandle: The window where the coordinate system shall be displayed
  //CamParam: The camera paramters
  //Pose: The pose to be displayed
  //CoordAxesLength: The length of the coordinate axes in world coordinates
  //
  //Check, if Pose is a correct pose tuple.
  if (0 != ((hv_Pose.TupleLength())!=7))
  {
    return;
  }
  get_cam_par_data(hv_CamParam, "camera_type", &hv_CameraType);
  hv_IsTelecentric = (hv_CameraType.TupleStrstr("telecentric"))!=-1;
  if (0 != (HTuple(HTuple(hv_Pose[2])==0.0).TupleAnd(hv_IsTelecentric.TupleNot())))
  {
    //For projective cameras:
    //Poses with Z position zero cannot be projected
    //(that would lead to a division by zero error).
    return;
  }
  //Convert to pose to a transformation matrix
  PoseToHomMat3d(hv_Pose, &hv_TransWorld2Cam);
  //Project the world origin into the image
  AffineTransPoint3d(hv_TransWorld2Cam, 0, 0, 0, &hv_OrigCamX, &hv_OrigCamY, &hv_OrigCamZ);
  Project3dPoint(hv_OrigCamX, hv_OrigCamY, hv_OrigCamZ, hv_CamParam, &hv_Row0, &hv_Column0);
  //Project the coordinate axes into the image
  AffineTransPoint3d(hv_TransWorld2Cam, hv_CoordAxesLength, 0, 0, &hv_X, &hv_Y, &hv_Z);
  Project3dPoint(hv_X, hv_Y, hv_Z, hv_CamParam, &hv_RowAxX, &hv_ColumnAxX);
  AffineTransPoint3d(hv_TransWorld2Cam, 0, hv_CoordAxesLength, 0, &hv_X, &hv_Y, &hv_Z);
  Project3dPoint(hv_X, hv_Y, hv_Z, hv_CamParam, &hv_RowAxY, &hv_ColumnAxY);
  AffineTransPoint3d(hv_TransWorld2Cam, 0, 0, hv_CoordAxesLength, &hv_X, &hv_Y, &hv_Z);
  Project3dPoint(hv_X, hv_Y, hv_Z, hv_CamParam, &hv_RowAxZ, &hv_ColumnAxZ);
  //
  //Generate an XLD contour for each axis
  DistancePp((hv_Row0.TupleConcat(hv_Row0)).TupleConcat(hv_Row0), (hv_Column0.TupleConcat(hv_Column0)).TupleConcat(hv_Column0), 
      (hv_RowAxX.TupleConcat(hv_RowAxY)).TupleConcat(hv_RowAxZ), (hv_ColumnAxX.TupleConcat(hv_ColumnAxY)).TupleConcat(hv_ColumnAxZ), 
      &hv_Distance);
  hv_HeadLength = ((((hv_Distance.TupleMax())/12.0).TupleConcat(5.0)).TupleMax()).TupleInt();
  gen_arrow_contour_xld(&ho_Arrows, (hv_Row0.TupleConcat(hv_Row0)).TupleConcat(hv_Row0), 
      (hv_Column0.TupleConcat(hv_Column0)).TupleConcat(hv_Column0), (hv_RowAxX.TupleConcat(hv_RowAxY)).TupleConcat(hv_RowAxZ), 
      (hv_ColumnAxX.TupleConcat(hv_ColumnAxY)).TupleConcat(hv_ColumnAxZ), hv_HeadLength, 
      hv_HeadLength);
  //
  //Display coordinate system
  DispXld(ho_Arrows, hv_WindowHandle);
  //
  GetRgb(hv_WindowHandle, &hv_Red, &hv_Green, &hv_Blue);
  SetRgb(hv_WindowHandle, HTuple(hv_Red[0]), HTuple(hv_Green[0]), HTuple(hv_Blue[0]));
  SetTposition(hv_WindowHandle, hv_RowAxX+3, hv_ColumnAxX+3);
  WriteString(hv_WindowHandle, "X");
  SetRgb(hv_WindowHandle, HTuple(hv_Red[1%(hv_Red.TupleLength())]), HTuple(hv_Green[1%(hv_Green.TupleLength())]), 
      HTuple(hv_Blue[1%(hv_Blue.TupleLength())]));
  SetTposition(hv_WindowHandle, hv_RowAxY+3, hv_ColumnAxY+3);
  WriteString(hv_WindowHandle, "Y");
  SetRgb(hv_WindowHandle, HTuple(hv_Red[2%(hv_Red.TupleLength())]), HTuple(hv_Green[2%(hv_Green.TupleLength())]), 
      HTuple(hv_Blue[2%(hv_Blue.TupleLength())]));
  SetTposition(hv_WindowHandle, hv_RowAxZ+3, hv_ColumnAxZ+3);
  WriteString(hv_WindowHandle, "Z");
  SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
  return;
}
