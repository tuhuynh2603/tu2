///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 13.0.2.2
///////////////////////////////////////////////////////////////////////////////




#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#endif



using namespace HalconCpp;

// Procedure declarations 
// Chapter: Calibration / Camera Parameters
// Short Description: Get the value of a specified camera parameter from the camera parameter tuple. 
extern void get_cam_par_data (HTuple hv_CameraParam, HTuple hv_ParamName, HTuple *hv_ParamValue);
// Chapter: 3D Object Model / Creation
// Short Description: Generate a symbolic 3D object model of a camera. 
void gen_camera_object_model_3d (HTuple hv_CameraSetupModel, HTuple hv_CamIndex, 
    HTuple hv_CameraSize, HTuple *hv_OM3DCam);
// Chapter: 3D Reconstruction / Multi-View Stereo
// Short Description: Estimate a bounding box for 3D reconstruction based on a stereo setup. 
void estimate_bounding_box_3d_reconstruction (HTuple hv_StereoModelID, HTuple hv_ObjectHeight, 
    HTuple *hv_BoundingBox);
// Chapter: 3D Object Model / Creation
// Short Description: Generate a 3D object model representing the view cone of a telecentric camera. 
void gen_cone_telecentric_object_model_3d (HTuple hv_CameraSetupModelID, HTuple hv_CameraIndex, 
    HTuple hv_ConeLength, HTuple *hv_ObjectModel3D);
// Chapter: 3D Object Model / Creation
// Short Description: Generate a 3D object model representing the view cone of a perspective camera. 
void gen_cone_perspective_object_model_3d (HTuple hv_CameraSetupModelID, HTuple hv_CameraIndex, 
    HTuple hv_ConeLength, HTuple *hv_ObjectModel3D);
// Chapter: 3D Object Model / Creation
// Short Description: Generate 3D object models which visualize the cameras of a stereo model. 
void gen_camera_setup_object_model_3d (HTuple hv_CameraSetupModelID, HTuple hv_CameraSize, 
    HTuple hv_ConeLength, HTuple *hv_ObjectModel3DCamera, HTuple *hv_ObjectModel3DCone);
// Chapter: 3D Object Model / Creation
// Short Description: Generate a 3D object model which visualizes the bounding box of a stereo model. 
void gen_bounding_box_object_model_3d (HTuple hv_StereoModelID, HTuple *hv_ObjectModel3DBoundingBox);

// Procedures 
// Chapter: 3D Object Model / Creation
// Short Description: Generate a symbolic 3D object model of a camera. 
void gen_camera_object_model_3d (HTuple hv_CameraSetupModel, HTuple hv_CamIndex, 
    HTuple hv_CameraSize, HTuple *hv_OM3DCam)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_LensePose, hv_CylinderLength, hv_ObjectModel3DLense;
  HTuple  hv_ObjectModel3DInit, hv_CamParams, hv_Type, hv_Tilt;
  HTuple  hv_Rot, hv_HomMat3DIdentity, hv_HomMat3DRotate;
  HTuple  hv_SensorToLenseRotation, hv_ObjectModel3DInitTilted;
  HTuple  hv_BoundingBox, hv_PX, hv_PY, hv_QZ, hv_PoseBack;
  HTuple  hv_ObjectModel3DInitTiltedBack, hv_CamPose, hv_OM3DSensor;
  HTuple  hv_OM3DLense;

  //
  //Generate a cylinder (lens) and move it behind the origin in direction z.
  CreatePose(0.0, 0.0, 0.0, 0, 0, 0, "Rp+T", "gba", "point", &hv_LensePose);
  hv_CylinderLength = hv_CameraSize/4.0;
  GenCylinderObjectModel3d(hv_LensePose, hv_CameraSize/2.0, (-hv_CylinderLength)/2.0, 
      0.0, &hv_ObjectModel3DLense);
  //
  //Generate a box (sensor housing) and tilt it, if necessary.
  GenBoxObjectModel3d(hv_LensePose, 1.0*hv_CameraSize, 1.0*hv_CameraSize, 1.0*hv_CameraSize, 
      &hv_ObjectModel3DInit);
  GetCameraSetupParam(hv_CameraSetupModel, hv_CamIndex, "params", &hv_CamParams);
  GetCameraSetupParam(hv_CameraSetupModel, hv_CamIndex, "type", &hv_Type);
  //
  //Distinguish cases with/without tilt.
  if (0 != (hv_Type.TupleRegexpTest("tilt")))
  {
    get_cam_par_data(hv_CamParams, "tilt", &hv_Tilt);
    get_cam_par_data(hv_CamParams, "rot", &hv_Rot);
  }
  else
  {
    hv_Tilt = 0;
    hv_Rot = 0;
  }
  HomMat3dIdentity(&hv_HomMat3DIdentity);
  HomMat3dRotate(hv_HomMat3DIdentity, hv_Tilt.TupleRad(), (((hv_Rot.TupleRad()).TupleCos()).TupleConcat((hv_Rot.TupleRad()).TupleSin())).TupleConcat(0), 
      0, 0, 0, &hv_HomMat3DRotate);
  HomMat3dToPose(hv_HomMat3DRotate, &hv_SensorToLenseRotation);
  RigidTransObjectModel3d(hv_ObjectModel3DInit, hv_SensorToLenseRotation, &hv_ObjectModel3DInitTilted);
  //
  //Move the sensor to a convenient position behind the lens.
  GetObjectModel3dParams(hv_ObjectModel3DInitTilted, "bounding_box1", &hv_BoundingBox);
  AffineTransPoint3d(hv_HomMat3DRotate, 0.0, 0.0, 0.5*hv_CameraSize, &hv_PX, &hv_PY, 
      &hv_QZ);
  CreatePose(-hv_PX, -hv_PY, (-HTuple(hv_BoundingBox[5]))-(hv_CylinderLength/2.0), 
      0, 0, 0, "Rp+T", "gba", "point", &hv_PoseBack);
  RigidTransObjectModel3d(hv_ObjectModel3DInitTilted, hv_PoseBack, &hv_ObjectModel3DInitTiltedBack);
  //
  //Move to the position of the camera in world coordinates.
  GetCameraSetupParam(hv_CameraSetupModel, hv_CamIndex, "pose", &hv_CamPose);
  RigidTransObjectModel3d(hv_ObjectModel3DInitTiltedBack, hv_CamPose, &hv_OM3DSensor);
  RigidTransObjectModel3d(hv_ObjectModel3DLense, hv_CamPose, &hv_OM3DLense);
  (*hv_OM3DCam).Clear();
  (*hv_OM3DCam).Append(hv_OM3DSensor);
  (*hv_OM3DCam).Append(hv_OM3DLense);
  //
  //Clean up.
  ClearObjectModel3d(hv_ObjectModel3DInit);
  ClearObjectModel3d(hv_ObjectModel3DInitTilted);
  ClearObjectModel3d(hv_ObjectModel3DInitTiltedBack);
  ClearObjectModel3d(hv_ObjectModel3DLense);
  return;
}

// Chapter: 3D Reconstruction / Multi-View Stereo
// Short Description: Estimate a bounding box for 3D reconstruction based on a stereo setup. 
void estimate_bounding_box_3d_reconstruction (HTuple hv_StereoModelID, HTuple hv_ObjectHeight, 
    HTuple *hv_BoundingBox)
{

  // Local iconic variables
  HObject  ho_PlaneConeIntersections, ho_ContourFrom;
  HObject  ho_ContourTo, ho_RectangleFrom, ho_RectangleTo;
  HObject  ho_ContoursIntersection, ho_PlaneConeIntersectionUnion;
  HObject  ho_ObjectSelected;

  // Local control variables
  HTuple  hv_CameraSetupModelID, hv_ReferenceCamera;
  HTuple  hv_From, hv_To, hv_NumCameras, hv_ObjectModel3DCone;
  HTuple  hv_DistanceCameras, hv_CameraIndex, hv_CamPose;
  HTuple  hv_DistanceCamera, hv_ConeLength, hv_Type, hv_ObjectModel3D;
  HTuple  hv_Index1, hv_ObjectModel3DIntersectionFrom, hv_ObjectModel3DIntersectionTo;
  HTuple  hv_XFrom, hv_YFrom, hv_XTo, hv_YTo, hv_Row, hv_Column;
  HTuple  hv_Phi, hv_Length1, hv_Length2, hv_Number, hv_Index2;
  HTuple  hv_RowContour, hv_ColumnContour;

  //The goal of this procedure is to estimate bounding box parameters
  //for 3D reconstruction. This is done by intersecting the
  //cones of sight of the cameras with a plane defined by the pose
  //of the reference calibration plate.
  //
  if (0 != (hv_ObjectHeight==0))
  {
    throw HException("Object height must not be zero.");
  }
  //Check whether the coordinate system has been moved by setting a pose
  //with the parameter 'coord_transf_pose' in set_camera_setup_param.
  //If this is not the case, the origin is still in one of the cameras.
  //However, this procedures needs the origin to be in a calibration plate.
  GetStereoModelParam(hv_StereoModelID, "camera_setup_model", &hv_CameraSetupModelID);
  GetCameraSetupParam(hv_CameraSetupModelID, "general", "reference_camera", &hv_ReferenceCamera);
  if (0 != (hv_ReferenceCamera!=-1))
  {
    throw HException("Please set the 'coord_transf_pose' to the pose of an calibration plate that lies horizontally in the image using the get_calib_data and set_camera_setup_param.");
  }
  //Check whether the image pairs have been set.
  GetStereoModelImagePairs(hv_StereoModelID, &hv_From, &hv_To);
  if (0 != (HTuple((hv_From.TupleLength())==0).TupleOr((hv_To.TupleLength())==0)))
  {
    throw HException("Please define the image pairs first with 'get_stereo_model_image_pairs.'");
  }
  //
  //First, we generate 3D object models that represent the cones of sight of the cameras,
  //like in the procedure gen_camera_setup_object_model_3d.
  GetCameraSetupParam(hv_CameraSetupModelID, "general", "num_cameras", &hv_NumCameras);
  hv_ObjectModel3DCone = HTuple();
  hv_DistanceCameras = HTuple();
  {
  HTuple end_val28 = hv_NumCameras-1;
  HTuple step_val28 = 1;
  for (hv_CameraIndex=0; hv_CameraIndex.Continue(end_val28, step_val28); hv_CameraIndex += step_val28)
  {
    GetCameraSetupParam(hv_CameraSetupModelID, hv_CameraIndex, "pose", &hv_CamPose);
    hv_DistanceCamera = (((HTuple(hv_CamPose[0])*HTuple(hv_CamPose[0]))+(HTuple(hv_CamPose[1])*HTuple(hv_CamPose[1])))+(HTuple(hv_CamPose[2])*HTuple(hv_CamPose[2]))).TupleSqrt();
    hv_DistanceCameras = hv_DistanceCameras.TupleConcat(hv_DistanceCamera);
    hv_ConeLength = hv_DistanceCamera*2.0;
    //Distinguish cases with/without projection center.
    GetCameraSetupParam(hv_CameraSetupModelID, hv_CameraIndex, "type", &hv_Type);
    if (0 != (hv_Type.TupleRegexpTest("telecentric")))
    {
      gen_cone_telecentric_object_model_3d(hv_CameraSetupModelID, hv_CameraIndex, 
          hv_ConeLength, &hv_ObjectModel3D);
    }
    else
    {
      gen_cone_perspective_object_model_3d(hv_CameraSetupModelID, hv_CameraIndex, 
          hv_ConeLength, &hv_ObjectModel3D);
    }
    hv_ObjectModel3DCone = hv_ObjectModel3DCone.TupleConcat(hv_ObjectModel3D);
  }
  }
  //
  //Then, we intersect these cones of sight with a plane that lies horizontally
  //in the origin of the stereo setup. We do this simultaneously for the
  //previously defined image pairs.
  GenEmptyObj(&ho_PlaneConeIntersections);
  {
  HTuple end_val47 = (hv_From.TupleLength())-1;
  HTuple step_val47 = 1;
  for (hv_Index1=0; hv_Index1.Continue(end_val47, step_val47); hv_Index1 += step_val47)
  {
    IntersectPlaneObjectModel3d(HTuple(hv_ObjectModel3DCone[HTuple(hv_From[hv_Index1])]), 
        ((((((HTuple(0).Append(0)).Append(0)).Append(0)).Append(0)).Append(0)).Append(0)), 
        &hv_ObjectModel3DIntersectionFrom);
    IntersectPlaneObjectModel3d(HTuple(hv_ObjectModel3DCone[HTuple(hv_To[hv_Index1])]), 
        ((((((HTuple(0).Append(0)).Append(0)).Append(0)).Append(0)).Append(0)).Append(0)), 
        &hv_ObjectModel3DIntersectionTo);
    //
    //Get the coordinates of the 3D object models that represent the intersection.
    GetObjectModel3dParams(hv_ObjectModel3DIntersectionFrom, "point_coord_x", &hv_XFrom);
    GetObjectModel3dParams(hv_ObjectModel3DIntersectionFrom, "point_coord_y", &hv_YFrom);
    GetObjectModel3dParams(hv_ObjectModel3DIntersectionTo, "point_coord_x", &hv_XTo);
    GetObjectModel3dParams(hv_ObjectModel3DIntersectionTo, "point_coord_y", &hv_YTo);
    //
    //The, we want to intersect the intersections of the image pair. We do this in 2D using XLDs.
    //Generate the XLD of the 'From' intersection.
    GenContourPolygonXld(&ho_ContourFrom, hv_XFrom, hv_YFrom);
    //Generate the XLD of the 'To' intersection.
    GenContourPolygonXld(&ho_ContourTo, hv_XTo, hv_YTo);
    //
    //The order of the coordinates from get_object_model_3d_params might not be ideal.
    //Thus, we compute the smallest rectangle around the created XLD.
    SmallestRectangle2Xld(ho_ContourFrom, &hv_Row, &hv_Column, &hv_Phi, &hv_Length1, 
        &hv_Length2);
    GenRectangle2ContourXld(&ho_RectangleFrom, hv_Row, hv_Column, hv_Phi, hv_Length1, 
        hv_Length2);
    SmallestRectangle2Xld(ho_ContourTo, &hv_Row, &hv_Column, &hv_Phi, &hv_Length1, 
        &hv_Length2);
    GenRectangle2ContourXld(&ho_RectangleTo, hv_Row, hv_Column, hv_Phi, hv_Length1, 
        hv_Length2);
    //
    //Intersect and concatenate the intersections
    IntersectionClosedContoursXld(ho_RectangleFrom, ho_RectangleTo, &ho_ContoursIntersection
        );
    ConcatObj(ho_PlaneConeIntersections, ho_ContoursIntersection, &ho_PlaneConeIntersections
        );
    ClearObjectModel3d(hv_ObjectModel3DIntersectionFrom);
    ClearObjectModel3d(hv_ObjectModel3DIntersectionTo);
  }
  }
  //
  //Union all intersections of all image pairs.
  GenEmptyObj(&ho_PlaneConeIntersectionUnion);
  CountObj(ho_PlaneConeIntersections, &hv_Number);
  {
  HTuple end_val80 = hv_Number;
  HTuple step_val80 = 1;
  for (hv_Index2=1; hv_Index2.Continue(end_val80, step_val80); hv_Index2 += step_val80)
  {
    SelectObj(ho_PlaneConeIntersections, &ho_ObjectSelected, hv_Index2);
    Union2ClosedContoursXld(ho_ObjectSelected, ho_PlaneConeIntersectionUnion, &ho_PlaneConeIntersectionUnion
        );
  }
  }
  //
  //Get the coordinates of the resulting XLD, which represents the area
  //in 2D where the reconstruction is possible.
  GetContourXld(ho_PlaneConeIntersectionUnion, &hv_RowContour, &hv_ColumnContour);
  //
  //Based on this contour, we can easily access the parameters of the bounding box.
  if (0 != (hv_ObjectHeight>0))
  {
    (*hv_BoundingBox).Clear();
    (*hv_BoundingBox).Append(hv_RowContour.TupleMin());
    (*hv_BoundingBox).Append(hv_ColumnContour.TupleMin());
    (*hv_BoundingBox).Append(-hv_ObjectHeight);
    (*hv_BoundingBox).Append(hv_RowContour.TupleMax());
    (*hv_BoundingBox).Append(hv_ColumnContour.TupleMax());
    (*hv_BoundingBox).Append(0);
  }
  else
  {
    (*hv_BoundingBox).Clear();
    (*hv_BoundingBox).Append(hv_RowContour.TupleMin());
    (*hv_BoundingBox).Append(hv_ColumnContour.TupleMin());
    (*hv_BoundingBox).Append(0);
    (*hv_BoundingBox).Append(hv_RowContour.TupleMax());
    (*hv_BoundingBox).Append(hv_ColumnContour.TupleMax());
    (*hv_BoundingBox).Append(-hv_ObjectHeight);
  }
  //
  //Clean up.
  ClearCameraSetupModel(hv_CameraSetupModelID);
  ClearObjectModel3d(hv_ObjectModel3DCone);
  return;
}

// Chapter: 3D Object Model / Creation
// Short Description: Generate a 3D object model representing the view cone of a telecentric camera. 
void gen_cone_telecentric_object_model_3d (HTuple hv_CameraSetupModelID, HTuple hv_CameraIndex, 
    HTuple hv_ConeLength, HTuple *hv_ObjectModel3D)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_CamPose, hv_HomMat3D, hv_CamParam;
  HTuple  hv_PX, hv_PY, hv_PZ, hv_QX, hv_QY, hv_QZ, hv_Qx;
  HTuple  hv_Qy, hv_Qz, hv_QZT, hv_Index, hv_Faces;
  HTupleVector  hvec_Points(1);

  GetCameraSetupParam(hv_CameraSetupModelID, hv_CameraIndex, "pose", &hv_CamPose);
  PoseToHomMat3d(hv_CamPose, &hv_HomMat3D);
  GetCameraSetupParam(hv_CameraSetupModelID, hv_CameraIndex, "params", &hv_CamParam);
  //
  //Get the lines of sight of the four corner points of the image.
  //Scale them to the given length and transform into world coordinates.
  hvec_Points = (HTupleVector(1).Insert(0,HTupleVector(HTuple())));
  //First corner.
  GetLineOfSight(0, 0, hv_CamParam, &hv_PX, &hv_PY, &hv_PZ, &hv_QX, &hv_QY, &hv_QZ);
  AffineTransPoint3d(hv_HomMat3D, hv_PX, hv_PY, hv_PZ, &hv_Qx, &hv_Qy, &hv_Qz);
  hvec_Points[0] = HTupleVector((hv_Qx.TupleConcat(hv_Qy)).TupleConcat(hv_Qz));
  hv_QZT = hv_ConeLength;
  AffineTransPoint3d(hv_HomMat3D, hv_QX, hv_QY, hv_QZT, &hv_Qx, &hv_Qy, &hv_Qz);
  hvec_Points[1] = HTupleVector((hv_Qx.TupleConcat(hv_Qy)).TupleConcat(hv_Qz));
  //Second corner.
  GetLineOfSight(HTuple(hv_CamParam[(hv_CamParam.TupleLength())-1])-1, 0, hv_CamParam, 
      &hv_PX, &hv_PY, &hv_PZ, &hv_QX, &hv_QY, &hv_QZ);
  AffineTransPoint3d(hv_HomMat3D, hv_PX, hv_PY, hv_PZ, &hv_Qx, &hv_Qy, &hv_Qz);
  hvec_Points[2] = HTupleVector((hv_Qx.TupleConcat(hv_Qy)).TupleConcat(hv_Qz));
  hv_QZT = hv_ConeLength;
  AffineTransPoint3d(hv_HomMat3D, hv_QX, hv_QY, hv_QZT, &hv_Qx, &hv_Qy, &hv_Qz);
  hvec_Points[3] = HTupleVector((hv_Qx.TupleConcat(hv_Qy)).TupleConcat(hv_Qz));
  //Third corner.
  GetLineOfSight(HTuple(hv_CamParam[(hv_CamParam.TupleLength())-1])-1, HTuple(hv_CamParam[(hv_CamParam.TupleLength())-2])-1, 
      hv_CamParam, &hv_PX, &hv_PY, &hv_PZ, &hv_QX, &hv_QY, &hv_QZ);
  AffineTransPoint3d(hv_HomMat3D, hv_PX, hv_PY, hv_PZ, &hv_Qx, &hv_Qy, &hv_Qz);
  hvec_Points[4] = HTupleVector((hv_Qx.TupleConcat(hv_Qy)).TupleConcat(hv_Qz));
  hv_QZT = hv_ConeLength;
  AffineTransPoint3d(hv_HomMat3D, hv_QX, hv_QY, hv_QZT, &hv_Qx, &hv_Qy, &hv_Qz);
  hvec_Points[5] = HTupleVector((hv_Qx.TupleConcat(hv_Qy)).TupleConcat(hv_Qz));
  //Fourth corner.
  GetLineOfSight(0, HTuple(hv_CamParam[(hv_CamParam.TupleLength())-2])-1, hv_CamParam, 
      &hv_PX, &hv_PY, &hv_PZ, &hv_QX, &hv_QY, &hv_QZ);
  AffineTransPoint3d(hv_HomMat3D, hv_PX, hv_PY, hv_PZ, &hv_Qx, &hv_Qy, &hv_Qz);
  hvec_Points[6] = HTupleVector((hv_Qx.TupleConcat(hv_Qy)).TupleConcat(hv_Qz));
  hv_QZT = hv_ConeLength;
  AffineTransPoint3d(hv_HomMat3D, hv_QX, hv_QY, hv_QZT, &hv_Qx, &hv_Qy, &hv_Qz);
  hvec_Points[7] = HTupleVector((hv_Qx.TupleConcat(hv_Qy)).TupleConcat(hv_Qz));
  //
  //Sort the points by coordinate direction.
  hv_PX = HTuple();
  hv_PY = HTuple();
  hv_PZ = HTuple();
  for (hv_Index=0; hv_Index<=7; hv_Index+=1)
  {
    hv_PX = hv_PX.TupleConcat(HTuple(hvec_Points[hv_Index].T()[0]));
    hv_PY = hv_PY.TupleConcat(HTuple(hvec_Points[hv_Index].T()[1]));
    hv_PZ = hv_PZ.TupleConcat(HTuple(hvec_Points[hv_Index].T()[2]));
  }
  GenObjectModel3dFromPoints(hv_PX, hv_PY, hv_PZ, &(*hv_ObjectModel3D));
  //
  //Set the sides of the cone.
  hv_Faces = HTuple();
  hv_Faces = hv_Faces.TupleConcat(((((HTuple(4).Append(0)).Append(1)).Append(3)).Append(2)));
  hv_Faces = hv_Faces.TupleConcat(((((HTuple(4).Append(2)).Append(3)).Append(5)).Append(4)));
  hv_Faces = hv_Faces.TupleConcat(((((HTuple(4).Append(4)).Append(5)).Append(7)).Append(6)));
  hv_Faces = hv_Faces.TupleConcat(((((HTuple(4).Append(6)).Append(7)).Append(1)).Append(0)));
  SetObjectModel3dAttribMod((*hv_ObjectModel3D), "polygons", HTuple(), hv_Faces);
  return;
}

// Chapter: 3D Object Model / Creation
// Short Description: Generate a 3D object model representing the view cone of a perspective camera. 
void gen_cone_perspective_object_model_3d (HTuple hv_CameraSetupModelID, HTuple hv_CameraIndex, 
    HTuple hv_ConeLength, HTuple *hv_ObjectModel3D)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_CamPose, hv_HomMat3D, hv_CamParam;
  HTuple  hv_PX, hv_PY, hv_PZ, hv_QX, hv_QY, hv_QZ, hv_QXT;
  HTuple  hv_QYT, hv_QZT, hv_Qx, hv_Qy, hv_Qz, hv_Index, hv_Faces;
  HTupleVector  hvec_Points(1);

  GetCameraSetupParam(hv_CameraSetupModelID, hv_CameraIndex, "pose", &hv_CamPose);
  PoseToHomMat3d(hv_CamPose, &hv_HomMat3D);
  GetCameraSetupParam(hv_CameraSetupModelID, hv_CameraIndex, "params", &hv_CamParam);
  //
  //Get the lines of sight of the four corner points of the image.
  //Scale them to the given length and transform into world coordinates.
  hvec_Points = (HTupleVector(1).Insert(0,HTupleVector(HTuple())));
  //First corner.
  GetLineOfSight(0, 0, hv_CamParam, &hv_PX, &hv_PY, &hv_PZ, &hv_QX, &hv_QY, &hv_QZ);
  hv_QXT = (hv_QX/hv_QZ)*hv_ConeLength;
  hv_QYT = (hv_QY/hv_QZ)*hv_ConeLength;
  hv_QZT = hv_ConeLength;
  AffineTransPoint3d(hv_HomMat3D, hv_QXT, hv_QYT, hv_QZT, &hv_Qx, &hv_Qy, &hv_Qz);
  hvec_Points[0] = HTupleVector((hv_Qx.TupleConcat(hv_Qy)).TupleConcat(hv_Qz));
  //Second corner.
  GetLineOfSight(HTuple(hv_CamParam[(hv_CamParam.TupleLength())-1])-1, 0, hv_CamParam, 
      &hv_PX, &hv_PY, &hv_PZ, &hv_QX, &hv_QY, &hv_QZ);
  hv_QXT = (hv_QX/hv_QZ)*hv_ConeLength;
  hv_QYT = (hv_QY/hv_QZ)*hv_ConeLength;
  hv_QZT = hv_ConeLength;
  AffineTransPoint3d(hv_HomMat3D, hv_QXT, hv_QYT, hv_QZT, &hv_Qx, &hv_Qy, &hv_Qz);
  hvec_Points[1] = HTupleVector((hv_Qx.TupleConcat(hv_Qy)).TupleConcat(hv_Qz));
  //Third corner.
  GetLineOfSight(HTuple(hv_CamParam[(hv_CamParam.TupleLength())-1])-1, HTuple(hv_CamParam[(hv_CamParam.TupleLength())-2])-1, 
      hv_CamParam, &hv_PX, &hv_PY, &hv_PZ, &hv_QX, &hv_QY, &hv_QZ);
  hv_QXT = (hv_QX/hv_QZ)*hv_ConeLength;
  hv_QYT = (hv_QY/hv_QZ)*hv_ConeLength;
  hv_QZT = hv_ConeLength;
  AffineTransPoint3d(hv_HomMat3D, hv_QXT, hv_QYT, hv_QZT, &hv_Qx, &hv_Qy, &hv_Qz);
  hvec_Points[2] = HTupleVector((hv_Qx.TupleConcat(hv_Qy)).TupleConcat(hv_Qz));
  //Fourth corner.
  GetLineOfSight(0, HTuple(hv_CamParam[(hv_CamParam.TupleLength())-2])-1, hv_CamParam, 
      &hv_PX, &hv_PY, &hv_PZ, &hv_QX, &hv_QY, &hv_QZ);
  hv_QXT = (hv_QX/hv_QZ)*hv_ConeLength;
  hv_QYT = (hv_QY/hv_QZ)*hv_ConeLength;
  hv_QZT = hv_ConeLength;
  AffineTransPoint3d(hv_HomMat3D, hv_QXT, hv_QYT, hv_QZT, &hv_Qx, &hv_Qy, &hv_Qz);
  hvec_Points[3] = HTupleVector((hv_Qx.TupleConcat(hv_Qy)).TupleConcat(hv_Qz));
  //
  //Get camera center.
  AffineTransPoint3d(hv_HomMat3D, 0, 0, 0, &hv_Qx, &hv_Qy, &hv_Qz);
  hvec_Points[4] = HTupleVector((hv_Qx.TupleConcat(hv_Qy)).TupleConcat(hv_Qz));
  //
  //Sort the points by coordinate direction.
  hv_PX = HTuple();
  hv_PY = HTuple();
  hv_PZ = HTuple();
  for (hv_Index=0; hv_Index<=4; hv_Index+=1)
  {
    hv_PX = hv_PX.TupleConcat(HTuple(hvec_Points[hv_Index].T()[0]));
    hv_PY = hv_PY.TupleConcat(HTuple(hvec_Points[hv_Index].T()[1]));
    hv_PZ = hv_PZ.TupleConcat(HTuple(hvec_Points[hv_Index].T()[2]));
  }
  GenObjectModel3dFromPoints(hv_PX, hv_PY, hv_PZ, &(*hv_ObjectModel3D));
  //
  //Set the sides of the cone.
  hv_Faces = HTuple();
  hv_Faces = hv_Faces.TupleConcat(((HTuple(4).Append(0)).Append(1)));
  hv_Faces = hv_Faces.TupleConcat(((HTuple(4).Append(1)).Append(2)));
  hv_Faces = hv_Faces.TupleConcat(((HTuple(4).Append(2)).Append(3)));
  hv_Faces = hv_Faces.TupleConcat(((HTuple(4).Append(3)).Append(0)));
  SetObjectModel3dAttribMod((*hv_ObjectModel3D), "triangles", HTuple(), hv_Faces);
  return;
}

// Chapter: 3D Object Model / Creation
// Short Description: Generate 3D object models which visualize the cameras of a stereo model. 
void gen_camera_setup_object_model_3d (HTuple hv_CameraSetupModelID, HTuple hv_CameraSize, 
    HTuple hv_ConeLength, HTuple *hv_ObjectModel3DCamera, HTuple *hv_ObjectModel3DCone)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_NumCameras, hv_AutoConeLength, hv_AllCameras;
  HTuple  hv_CurrentCamera, hv_ConcatZ, hv_OtherCameras, hv_Index;
  HTuple  hv_CamParam0, hv_Pose0, hv_CamParam1, hv_Pose1;
  HTuple  hv_PoseInvert, hv_RelPose, hv_CX0, hv_CY0, hv_CX1;
  HTuple  hv_CY1, hv_X, hv_Y, hv_Z, hv_Dist, hv_Exception;
  HTuple  hv_CameraType, hv_ObjectModel3DConeTmp, hv_ObjectModel3DCameraTmp;

  GetCameraSetupParam(hv_CameraSetupModelID, "general", "num_cameras", &hv_NumCameras);
  //
  //Consistency check:
  if (0 != (hv_NumCameras<1))
  {
    throw HException("No camera set.");
  }
  if (0 != (hv_CameraSize.TupleIsNumber()))
  {
    if (0 != (hv_CameraSize<=0.0))
    {
      throw HException("Invalid value for CameraSize. CameraSize must be positive or 'auto'.");
    }
  }
  else if (0 != (hv_CameraSize!=HTuple("auto")))
  {
    throw HException("Invalid value for CameraSize. CameraSize must be positive or 'auto'.");
  }
  if (0 != (hv_ConeLength.TupleIsNumber()))
  {
    if (0 != (hv_ConeLength<=0.0))
    {
      throw HException("Invalid value for ConeLength. ConeLength must be positive or 'auto'.");
    }
  }
  else if (0 != (hv_ConeLength!=HTuple("auto")))
  {
    throw HException("Invalid value for ConeLength. ConeLength must be positive or 'auto'.");
  }
  //
  hv_AutoConeLength = hv_ConeLength==HTuple("auto");
  //
  (*hv_ObjectModel3DCamera) = HTuple();
  (*hv_ObjectModel3DCone) = HTuple();
  hv_AllCameras = HTuple::TupleGenSequence(0,hv_NumCameras-1,1);
  {
  HTuple end_val26 = hv_NumCameras-1;
  HTuple step_val26 = 1;
  for (hv_CurrentCamera=0; hv_CurrentCamera.Continue(end_val26, step_val26); hv_CurrentCamera += step_val26)
  {
    hv_ConcatZ = HTuple();
    if (0 != hv_AutoConeLength)
    {
      if (0 != (hv_NumCameras<2))
      {
        throw HException("You need at least two cameras for ConeLength == auto.");
      }
      //Intersect the line of sight of each camera with all other cameras.
      hv_OtherCameras = hv_AllCameras.TupleRemove(hv_AllCameras.TupleFind(hv_CurrentCamera));
      {
      HTuple end_val34 = (hv_OtherCameras.TupleLength())-1;
      HTuple step_val34 = 1;
      for (hv_Index=0; hv_Index.Continue(end_val34, step_val34); hv_Index += step_val34)
      {
        GetCameraSetupParam(hv_CameraSetupModelID, hv_CurrentCamera, "params", &hv_CamParam0);
        GetCameraSetupParam(hv_CameraSetupModelID, hv_CurrentCamera, "pose", &hv_Pose0);
        GetCameraSetupParam(hv_CameraSetupModelID, HTuple(hv_OtherCameras[hv_Index]), 
            "params", &hv_CamParam1);
        GetCameraSetupParam(hv_CameraSetupModelID, HTuple(hv_OtherCameras[hv_Index]), 
            "pose", &hv_Pose1);
        //Intersect the lines of sight of the camera pair.
        PoseInvert(hv_Pose1, &hv_PoseInvert);
        PoseCompose(hv_PoseInvert, hv_Pose0, &hv_RelPose);
        get_cam_par_data(hv_CamParam0, "cx", &hv_CX0);
        get_cam_par_data(hv_CamParam0, "cy", &hv_CY0);
        get_cam_par_data(hv_CamParam1, "cx", &hv_CX1);
        get_cam_par_data(hv_CamParam1, "cy", &hv_CY1);
        try
        {
          IntersectLinesOfSight(hv_CamParam0, hv_CamParam1, hv_RelPose, hv_CY0, hv_CX0, 
              hv_CY1, hv_CX1, &hv_X, &hv_Y, &hv_Z, &hv_Dist);
        }
        // catch (Exception) 
        catch (HException &HDevExpDefaultException)
        {
          HDevExpDefaultException.ToHTuple(&hv_Exception);
          throw HException("Estimating a value for ConeLength automatically was not possible. Please use a number instead.");
        }
        hv_ConcatZ = hv_ConcatZ.TupleConcat(hv_Z);
      }
      }
      //Use the Z value of the determined coordinates as basis for the ConeLength.
      hv_ConeLength = (hv_ConcatZ.TupleMax())*1.05;
    }
    //
    //Create cone of sight 3D object models.
    //Distinguish cases with/without projection center.
    GetCameraSetupParam(hv_CameraSetupModelID, hv_CurrentCamera, "type", &hv_CameraType);
    if (0 != (hv_CameraType.TupleRegexpTest("telecentric")))
    {
      gen_cone_telecentric_object_model_3d(hv_CameraSetupModelID, hv_CurrentCamera, 
          hv_ConeLength, &hv_ObjectModel3DConeTmp);
    }
    else
    {
      gen_cone_perspective_object_model_3d(hv_CameraSetupModelID, hv_CurrentCamera, 
          hv_ConeLength, &hv_ObjectModel3DConeTmp);
    }
    (*hv_ObjectModel3DCone) = (*hv_ObjectModel3DCone).TupleConcat(hv_ObjectModel3DConeTmp);
    //
    //Create camera 3D object models.
    if (0 != (hv_CameraSize==HTuple("auto")))
    {
      //In auto mode, the camera size for all cameras
      //is defined by the first camera's cone length.
      hv_CameraSize = hv_ConeLength*0.1;
    }
    gen_camera_object_model_3d(hv_CameraSetupModelID, hv_CurrentCamera, hv_CameraSize, 
        &hv_ObjectModel3DCameraTmp);
    (*hv_ObjectModel3DCamera) = (*hv_ObjectModel3DCamera).TupleConcat(hv_ObjectModel3DCameraTmp);
  }
  }
  return;
}

// Chapter: 3D Object Model / Creation
// Short Description: Generate a 3D object model which visualizes the bounding box of a stereo model. 
void gen_bounding_box_object_model_3d (HTuple hv_StereoModelID, HTuple *hv_ObjectModel3DBoundingBox)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_BoundingBox, hv_PX, hv_PY, hv_PZ, hv_Index;
  HTuple  hv_Faces;
  HTupleVector  hvec_Points(1);

  //
  //Consistency check:
  GetStereoModelParam(hv_StereoModelID, "bounding_box", &hv_BoundingBox);
  if (0 != (HTuple(HTuple(HTuple(hv_BoundingBox[3])<HTuple(hv_BoundingBox[0])).TupleOr(HTuple(hv_BoundingBox[4])<HTuple(hv_BoundingBox[1]))).TupleOr(HTuple(hv_BoundingBox[5])<HTuple(hv_BoundingBox[2]))))
  {
    throw HException("Invalid bounding box or bounding box not set yet.");
  }
  //
  //Get the eight corner points from the min/max representation.
  hvec_Points = (HTupleVector(1).Insert(0,HTupleVector(HTuple())));
  hvec_Points[0] = HTupleVector((HTuple(hv_BoundingBox[0]).TupleConcat(HTuple(hv_BoundingBox[1]))).TupleConcat(HTuple(hv_BoundingBox[2])));
  hvec_Points[1] = HTupleVector((HTuple(hv_BoundingBox[3]).TupleConcat(HTuple(hv_BoundingBox[1]))).TupleConcat(HTuple(hv_BoundingBox[2])));
  hvec_Points[2] = HTupleVector((HTuple(hv_BoundingBox[3]).TupleConcat(HTuple(hv_BoundingBox[4]))).TupleConcat(HTuple(hv_BoundingBox[2])));
  hvec_Points[3] = HTupleVector((HTuple(hv_BoundingBox[0]).TupleConcat(HTuple(hv_BoundingBox[4]))).TupleConcat(HTuple(hv_BoundingBox[2])));
  hvec_Points[4] = HTupleVector((HTuple(hv_BoundingBox[0]).TupleConcat(HTuple(hv_BoundingBox[1]))).TupleConcat(HTuple(hv_BoundingBox[5])));
  hvec_Points[5] = HTupleVector((HTuple(hv_BoundingBox[3]).TupleConcat(HTuple(hv_BoundingBox[1]))).TupleConcat(HTuple(hv_BoundingBox[5])));
  hvec_Points[6] = HTupleVector((HTuple(hv_BoundingBox[3]).TupleConcat(HTuple(hv_BoundingBox[4]))).TupleConcat(HTuple(hv_BoundingBox[5])));
  hvec_Points[7] = HTupleVector((HTuple(hv_BoundingBox[0]).TupleConcat(HTuple(hv_BoundingBox[4]))).TupleConcat(HTuple(hv_BoundingBox[5])));
  //
  //Sort the corner points by coordinate direction.
  hv_PX = HTuple();
  hv_PY = HTuple();
  hv_PZ = HTuple();
  for (hv_Index=0; hv_Index<=7; hv_Index+=1)
  {
    hv_PX = hv_PX.TupleConcat(HTuple(hvec_Points[hv_Index].T()[0]));
    hv_PY = hv_PY.TupleConcat(HTuple(hvec_Points[hv_Index].T()[1]));
    hv_PZ = hv_PZ.TupleConcat(HTuple(hvec_Points[hv_Index].T()[2]));
  }
  GenObjectModel3dFromPoints(hv_PX, hv_PY, hv_PZ, &(*hv_ObjectModel3DBoundingBox));
  //
  //Set the sides of the cuboid.
  hv_Faces = HTuple();
  hv_Faces = hv_Faces.TupleConcat(((((HTuple(4).Append(0)).Append(1)).Append(5)).Append(4)));
  hv_Faces = hv_Faces.TupleConcat(((((HTuple(4).Append(1)).Append(2)).Append(6)).Append(5)));
  hv_Faces = hv_Faces.TupleConcat(((((HTuple(4).Append(2)).Append(3)).Append(7)).Append(6)));
  hv_Faces = hv_Faces.TupleConcat(((((HTuple(4).Append(3)).Append(0)).Append(4)).Append(7)));
  hv_Faces = hv_Faces.TupleConcat(((((HTuple(4).Append(0)).Append(1)).Append(2)).Append(3)));
  hv_Faces = hv_Faces.TupleConcat(((((HTuple(4).Append(4)).Append(5)).Append(6)).Append(7)));
  SetObjectModel3dAttribMod((*hv_ObjectModel3DBoundingBox), "polygons", HTuple(), 
      hv_Faces);
  return;
}


